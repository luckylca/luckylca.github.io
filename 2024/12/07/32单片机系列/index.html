<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>32单片机系列 | Lucky</title><meta name="author" content="lca"><meta name="copyright" content="lca"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="32单片机系列51的学习暂时告一段落，也要继续学习stm32了。目前用的板子是江协的stm32f103c8的版本，先尝试着学习一下标准库的用法，虽然很难，但可以很好的理解计算机底层内容，尽力学吧，实在受不了就转向stmcubmax加hal库的方案。 1.GPIOGPIO全拼叫General Purpose Input Output（通用输入输出）简称IO口，作用是用来控制连接在此GPIO口上的外设">
<meta property="og:type" content="article">
<meta property="og:title" content="32单片机系列">
<meta property="og:url" content="http://example.com/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/index.html">
<meta property="og:site_name" content="Lucky">
<meta property="og:description" content="32单片机系列51的学习暂时告一段落，也要继续学习stm32了。目前用的板子是江协的stm32f103c8的版本，先尝试着学习一下标准库的用法，虽然很难，但可以很好的理解计算机底层内容，尽力学吧，实在受不了就转向stmcubmax加hal库的方案。 1.GPIOGPIO全拼叫General Purpose Input Output（通用输入输出）简称IO口，作用是用来控制连接在此GPIO口上的外设">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.png">
<meta property="article:published_time" content="2024-12-07T10:17:02.000Z">
<meta property="article:modified_time" content="2025-05-05T04:38:55.725Z">
<meta property="article:author" content="lca">
<meta property="article:tag" content="单片机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '32单片机系列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-05 12:38:55'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Lucky</span></a><a class="nav-page-title" href="/"><span class="site-name">32单片机系列</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">32单片机系列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-07T10:17:02.000Z" title="发表于 2024-12-07 18:17:02">2024-12-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-05T04:38:55.725Z" title="更新于 2025-05-05 12:38:55">2025-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="32单片机系列"><a href="#32单片机系列" class="headerlink" title="32单片机系列"></a>32单片机系列</h1><p>51的学习暂时告一段落，也要继续学习stm32了。目前用的板子是江协的stm32f103c8的版本，先尝试着学习一下标准库的用法，虽然很难，但可以很好的理解计算机底层内容，尽力学吧，实在受不了就转向stmcubmax加hal库的方案。</p>
<h2 id="1-GPIO"><a href="#1-GPIO" class="headerlink" title="1.GPIO"></a>1.GPIO</h2><p>GPIO全拼叫General Purpose Input Output（通用输入输出）简称IO口，作用是用来控制连接在此GPIO口上的外设，通俗来说，就是单片机芯片通过控制IO口的电流输出，来起到控制外设的作用。</p>
<p>GPIO原理图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-12-12174243.png" alt="屏幕截图2024-12-12174243"></p>
<p>一共有8种方式，但是一般常用输出方式就是推挽输出和开漏输出，而常用的输入方式是上拉输入和下拉输入，两者的区别就在于当没有外设给io口电平时，二者的默认电平不一样。</p>
<p>推挽输出同时支持高低电平驱动，方便快速切换电平，但是不支持线与（这个目前还没接触过），开漏输出就只支持低电平输入，电压取决于外部电压。</p>
<h2 id="点灯-蜂鸣器"><a href="#点灯-蜂鸣器" class="headerlink" title="点灯+蜂鸣器"></a>点灯+蜂鸣器</h2><h3 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h3><p>又是熟悉的点灯环节。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;stm32f10x.h&quot;                  // Device header</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);		<span class="comment">//初始化时钟</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;		<span class="comment">//定义gpio的一个结构体</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;		</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		<span class="comment">//分别设置结构体的三个参数</span></span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);		<span class="comment">//初始化GPIO</span></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);		<span class="comment">//可以写入对应IO口的值</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/A441DB3829A9723EC109E8F8ACA8D7E1.jpg" alt="A441DB3829A9723EC109E8F8ACA8D7E1"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个就引入了延时函数，可以实现小灯的频闪，但是这个32的delay函数跟51一样，还是通过执行无用的指令来拖延时间。</p>
<h3 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本质上是一样的，无非就是改一下初始化的GPIO口，和调整对应的赋值。</p>
<p>然后蜂鸣器有三个接口，用公母线连接到面包板上，分别是vcc，gnd和控制音频的引脚。也是跟小灯一样的赋值即可。</p>
<h2 id="GPIO输入"><a href="#GPIO输入" class="headerlink" title="GPIO输入"></a>GPIO输入</h2><h3 id="按钮控制点灯"><a href="#按钮控制点灯" class="headerlink" title="按钮控制点灯"></a>按钮控制点灯</h3><p>首先是按钮驱动的配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> KeyNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>);</span><br><span class="line">		KeyNum=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>);</span><br><span class="line">		KeyNum=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> KeyNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>都是先是正常的初始化函数，即设置GPIO参数，然后再写读取按钮函数，通过返回8位的int数据，来表示按钮的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	LED_Init();</span><br><span class="line">	Key_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();</span><br><span class="line">		<span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED1_Turn();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED2_Turn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是主函数，逻辑很简单，就是通过判断Key_GetNum返回的值来判断按键的状态，其中，LED_Turn函数的内容就是如果GPIO输出为1就置为0，为0就置为1，的一个简单的反转函数。</p>
<h3 id="光敏传感器"><a href="#光敏传感器" class="headerlink" title="光敏传感器"></a>光敏传感器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LightSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_SetBits(GPIOB,GPIO_Pin_13);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LightSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>都大同小异，光敏传感器驱动也是一样的初始化函数加一个读取函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;   // Device header</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;LED.h&quot;</span><br><span class="line">#include &quot;key.h&quot;</span><br><span class="line">#include &quot;Buzzer.h&quot;</span><br><span class="line">#include &quot;LightSensor.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	Buzzer_Init();</span><br><span class="line">	LightSensor_Init();</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(LightSensor_Get()==1)</span><br><span class="line">			Buzzer_ON();</span><br><span class="line">		else</span><br><span class="line">			Buzzer_OFF();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样就实现了当光不照射时，蜂鸣器一直响，当光照射时，蜂鸣器不响。</p>
<h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><p>这个跟51单片机类似，用的是江科协的库，直接调用对应的函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	OLED_ShowChar(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">	OLED_ShowNum(<span class="number">2</span>,<span class="number">1</span>,<span class="number">12345</span>,<span class="number">5</span>);</span><br><span class="line">	OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">7</span>,<span class="number">-66</span>,<span class="number">3</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,<span class="number">0xAA55</span>,<span class="number">4</span>);		<span class="comment">//显示十六进制</span></span><br><span class="line">	OLED_ShowBinNum(<span class="number">4</span>,<span class="number">1</span>,<span class="number">0xAA55</span>,<span class="number">16</span>);		<span class="comment">//显示二进制</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>OLED所用的芯片SSD1306支持spi和iic通信，但是我的OLED只有两个iic通信接口，于是就是用iic通信了。</p>
<p>iic底层用的是软件模拟iic，不需要改动什么。</p>
<p>这款OLED是128*64的分辨率，所有的显示信息都储存在GDDRAM中，芯片会不断扫描这个GDDROM，将结果显示在OLED屏幕上，所以我们只需要对GDDRAM进行操作就可以了。</p>
<p>而这128*64又可以被分为 128*8byte，所以整个结构可以分为竖着的是128列，横着的是8页，一页就是一个字节，数据的存储就是一个字节的数据对用一列的一页，扫描也是从上到下，一页一页地扫描。</p>
<p>关键是拼凑SSD1306所需要的通信结构，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-05-02_01-30-11.png" alt="PixPin_2025-05-02_01-30-11"></p>
<p>如上图所示，首先是起始信号，然后是从机地址跟读写位的设置，因为这个模块只写不读，所以这个字节直接设置为0x78就可以了，然后下一个数据是设置dc和连续性，其中dc置0就是命令模式，置1就是数据模式，co可以设置连续或者非连续发送，不过一般都是使用非连续发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OLED_WriteCommand</span><span class="params">(<span class="type">uint8_t</span> command)</span><span class="comment">//写入命令的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x78</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x00</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(command);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WriteData</span><span class="params">(<span class="type">uint8_t</span> data)</span><span class="comment">//写入数据的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x78</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x40</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(data);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面是一些基础函数。</p>
<p>然后就可以基于基础函数构造一些高级的函数了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myoled_Init</span><span class="params">()</span><span class="comment">//初始化函数，具体操作细节可以查看手册</span></span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_Init();</span><br><span class="line">	Delay_ms(<span class="number">100</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xAE</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xD5</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x80</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA8</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x3F</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xD3</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x00</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x40</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA1</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xC8</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xDA</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x12</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x81</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xCF</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xD9</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xF1</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xDB</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x30</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA4</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA6</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x8D</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x14</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xAF</span>);</span><br><span class="line">	Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SetCursor</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page)</span><span class="comment">//设置写入的位置，相当于设置鼠标光标位置</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x00</span> | (x &amp; <span class="number">0x0F</span>));</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x10</span> | ((x &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>));</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xB0</span> | page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">()</span><span class="comment">//清屏函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> j = <span class="number">0</span>;j&lt;<span class="number">8</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_SetCursor(<span class="number">0</span>,j);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(<span class="number">0x00</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">char</span> ch,<span class="type">uint8_t</span> fontsize)</span><span class="comment">//展示单个字符</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(fontsize==<span class="number">6</span>)&#123;</span><br><span class="line">		OLED_SetCursor(x,page);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(ascii_6x8[ch - <span class="string">&#x27; &#x27;</span>][i]);<span class="comment">//ascii_6x8是一个二维数组，存放取模出来的ascall码</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(fontsize==<span class="number">8</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_SetCursor(x,page);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(OLED_F8_16[ch - <span class="string">&#x27; &#x27;</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		OLED_SetCursor(x,page+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(OLED_F8_16[ch - <span class="string">&#x27; &#x27;</span>][i+<span class="number">8</span>]);</span><br><span class="line">		&#125;		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">char</span> *ch,<span class="type">uint8_t</span> fontsize)</span><span class="comment">//遍历展示字符串</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;ch[i] != <span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowChar(x+i*fontsize,page,ch[i],fontsize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowImg</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">uint8_t</span> width,<span class="type">uint8_t</span> height,<span class="type">uint8_t</span> *img)</span><span class="comment">//显示图片</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> j=<span class="number">0</span>;j&lt;height;j++)<span class="comment">//这里的height准确来说应该是page</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_SetCursor(x,page+j);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;width;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(img[width*j+i]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChinese</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">char</span> *Chinese)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> signalchinese[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//存储单个中文</span></span><br><span class="line">	<span class="comment">//char signalchinese[4] = &quot;中&quot;; // 实际存储为 &#123;&#x27;\xE4&#x27;, &#x27;\xB8&#x27;, &#x27;\xAD&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line">	<span class="type">uint8_t</span> pchinese = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint8_t</span> pindex ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;Chinese[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		signalchinese[pchinese] = Chinese[i];</span><br><span class="line">		pchinese++;</span><br><span class="line">		<span class="keyword">if</span>(pchinese&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">			pchinese=<span class="number">0</span>;<span class="comment">//到了3就可以拿出一个单个的中文出来了。</span></span><br><span class="line">			<span class="keyword">for</span>(pindex=<span class="number">0</span>;<span class="built_in">strcmp</span>(OLED_CF_16_16[pindex].Index,<span class="string">&quot;&quot;</span>)!=<span class="number">0</span>;pindex++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strcmp</span>(OLED_CF_16_16[pindex].Index,signalchinese) == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果遍历字模库中发现有相同的中文，就立马退出循环，显示中文</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			OLED_ShowImg(x+((i+<span class="number">1</span>)/<span class="number">3</span><span class="number">-1</span>)*<span class="number">16</span>),page,<span class="number">16</span>,<span class="number">2</span>,OLED_CF_16_16[pindex].Data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是关于中文字模的结构体定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> Index[<span class="number">4</span>];</span><br><span class="line">	<span class="type">uint8_t</span> Data[<span class="number">32</span>];</span><br><span class="line">&#125; ChineseCell_t;</span><br><span class="line"><span class="type">const</span> ChineseCell_t OLED_CF_16_16[]=</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;你&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0xF8</span>,<span class="number">0x07</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x0F</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="comment">/*,0*/</span></span><br><span class="line"><span class="string">&quot;好&quot;</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x1F</span>,<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0xE2</span>,<span class="number">0x92</span>,<span class="number">0x8A</span>,<span class="number">0x86</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x40</span>,<span class="number">0x22</span>,<span class="number">0x15</span>,<span class="number">0x08</span>,<span class="number">0x16</span>,<span class="number">0x61</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*,1*/</span></span><br><span class="line"><span class="string">&quot;世&quot;</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFE</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x47</span>,<span class="number">0x44</span>,<span class="number">0x44</span>,<span class="number">0x44</span>,<span class="number">0x47</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*,2*/</span></span><br><span class="line"><span class="string">&quot;界&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0xFE</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x84</span>,<span class="number">0x62</span>,<span class="number">0x1E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="comment">/*,3*/</span></span><br><span class="line"><span class="string">&quot;    &quot;</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将中文字模储存到OLED_CF_16_16里面就可以了。</p>
<p>以上的内容都是无缓冲区实现OLED显示的，无缓冲区的缺点就是不能在两个页码之间显示数据，只能上下两个页码同时写满。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="对射红外传感器计次"><a href="#对射红外传感器计次" class="headerlink" title="对射红外传感器计次"></a>对射红外传感器计次</h3><p>这里跟51单片机的定时器情况类似，32就直接引入了中断的概念，像我的stm32f103有68种中断函数，有硬件中断也有定时器中断还有EXIT中断等等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1735054774083.png" alt="1735054774083"></p>
<p>这就是EXIT中断的简要流程图，我们也需要根据图上的内容来依次配置寄存器，用hal库。</p>
<p>首先第一个是AFIO，AFIO的作用是从多个GPIO接口中筛选出一个16接口来交给EXIT，避免线太多的麻烦，所以在配置EXIT中断时，选择监视的接口的端口位数不能有重复的，就比如不能同时设置GPIO_PinB1和GPIO_PinA1同时作为EXIT检测的io口，这样会出错。</p>
<p>然后就是EXIT的设置，跟GPIO的初始化配置类似，先是定义一个结构体，然后再交给hal库取值处理。</p>
<p>最后就是NVIC，这个东西的作用就是起到全局调度，设置好中断优先级以后，NVIC会配置好中断步骤，然后再交给。中断优先级可以分为抢占优先级和子优先级，其中抢占优先级是可以进行中断嵌套的，而子优先级的中断只能当本次中断执行结束后再执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);		<span class="comment">//AFIO配置</span></span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructre;</span><br><span class="line">	EXTI_InitStructre.EXTI_LineCmd = ENABLE;					<span class="comment">//打开使能</span></span><br><span class="line">	EXTI_InitStructre.EXTI_Mode = EXTI_Mode_Interrupt;			<span class="comment">//设置中断模式还是事件模式</span></span><br><span class="line">	EXTI_InitStructre.EXTI_Trigger = EXTI_Trigger_Falling;		<span class="comment">//下降沿触发模式</span></span><br><span class="line">	EXTI_InitStructre.EXTI_Line = EXTI_Line14;					<span class="comment">//设置具体的线</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructre);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//NVIC通道</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//NVIC使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//NVIC权限设置，数字越小越先执行</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line14)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		CountSensor_Count++;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line14);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这就是简单的一个光线传感器的计数模块，利用了中断函数进行计数。</p>
<h3 id="旋转编码计次"><a href="#旋转编码计次" class="headerlink" title="旋转编码计次"></a>旋转编码计次</h3><p>这里用到了一个简单的旋转编码器，在连接vcc跟gnd和两个信号传输线后就可以正常使用了。有A相和B相输出，其中两向之间存在相位差，正转：如果A相先于B相变化，则表示编码器正转。反转：如果B相先于A相变化，则表示编码器反转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Encoder_Count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);</span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">	EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;</span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int16_t</span> Temp;</span><br><span class="line">	Temp = Encoder_Count;</span><br><span class="line">	Encoder_Count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count --;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line1) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编码器核心代码如上，当触发中断的时候，快速判断另一个头是不是低电平，来实现判断正转和反转，并进行+1和-1的操作。在主程序中只用num+&#x3D;Encoder_Get()即可，并打印出num的值。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器是stm32中的重要组成部分之一，跟51单片机有所不同，stm32中的定时器是从0开始向上计数，最大可以计数计到65535，我们要设置的通常是设置计到多少就触发中断，比如说可以设置1000-1，-1则是因为定时器的计数是从0开始计算的，所以需要-1才可以真实的达到1000.</p>
<p>先来张定时器原理图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1743941133773.jpg" alt="1743941133773"></p>
<p>一般我们使用的都是内部时钟，这里的重点是时基单元的配置，第一是预分频器，预分频器就相当于把晶振的频率先做一次处理，然后再进行计数，如果计数的值达到了自动重装器的目标值，就进入中断。同样，定时器也与nvic的中断优先级的设置。</p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>先上张PWM的原理图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1743941133763.jpg" alt="1743941133763"></p>
<p>本质上就是在定时器的后面加上了一个输出比较。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1743941133769.jpg" alt="1743941133769"></p>
<p>这是输出比较模式的配置，基本上就是使用PWM模式1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_Initstructure;</span><br><span class="line">	GPIO_Initstructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_Initstructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_Initstructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_Initstructure);		<span class="comment">//GPIo初始化</span></span><br><span class="line">	</span><br><span class="line">	TIM_InternalClockConfig(TIM2);<span class="comment">//设置TIM2为内部时钟源</span></span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;</span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//设置时钟源分频</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//设置为向上开始计数的模式</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_Period = <span class="number">100</span><span class="number">-1</span>;<span class="comment">//自动重装的值，就是计数达到这个值触发中断</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//高级定时器中的重复计数器，这里不用，设置为0</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStruct);			<span class="comment">//时基单元配置</span></span><br><span class="line">	</span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStruct;</span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStruct);<span class="comment">//初始化结构体，设置其他的为默认参数</span></span><br><span class="line">	TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;<span class="comment">//设置输出比较模式</span></span><br><span class="line">	TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;<span class="comment">//设置有效电平为高电平</span></span><br><span class="line">	TIM_OCInitStruct.TIM_Pulse = <span class="number">0</span>;<span class="comment">//设置比较器，就是定时器计数到多少的时候触发</span></span><br><span class="line">	TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">	TIM_OC1Init(TIM2,&amp;TIM_OCInitStruct);		<span class="comment">//PWM模式配置</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM2,ENABLE);		<span class="comment">//开启定时器</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_Set2Compare1</span><span class="params">(<span class="type">uint16_t</span> compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare1(TIM2,compare);		<span class="comment">//设置PWM的比较器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的是PWM.c的配置，封装了一些基本的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;PWM.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	PWM_Init();</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=0;i&lt;=100;i++)&#123;</span><br><span class="line">			TIM_Set2Compare1(i);</span><br><span class="line">			Delay_ms(10);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;=100;i++)&#123;</span><br><span class="line">			TIM_Set2Compare1(100-i);</span><br><span class="line">			Delay_ms(10);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是主函数的配置，通过delay加上合理设置PWM的输出比较器，最终实现呼吸灯的效果。</p>
<p>呼吸灯还有另一个改进的版本，就是使用了两个定时器来完成呼吸灯的操作，一个是用来输出PWM信号，还有一个定时器是用来延时，具体的作用就是上述第一个版本的定时器的这个代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delay_ms(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>



<p>具体函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) &#123;</span><br><span class="line">        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);</span><br><span class="line">        <span class="comment">// 在此处添加需要定时执行的代码</span></span><br><span class="line">        <span class="keyword">if</span> (pwmEnabled) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">uint8_t</span> direction = <span class="number">0</span>;</span><br><span class="line">            <span class="type">static</span> <span class="type">uint16_t</span> pwmValue = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 呼吸灯效果逻辑（示例）</span></span><br><span class="line">            <span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">                pwmValue += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pwmValue &gt;= <span class="number">100</span>) direction = <span class="number">1</span>;  <span class="comment">// 假设PWM周期为1000</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pwmValue -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pwmValue == <span class="number">0</span>) direction = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新PWM占空比（假设使用TIM2_CH1）</span></span><br><span class="line">            TIM_SetCompare1(TIM2, pwmValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就是这样子设置一个10ms的定时器，没10ms就会跑一下这个程序，这个10ms是至关重要的，如果不设置这个10ms，那么就不会有呼吸灯的效果了，就只会保持一个中等的亮度，有了人为加的10ms，延长了时间，人眼看上去就不是一个恒定的亮度。</p>
<h2 id="ADC数模转换"><a href="#ADC数模转换" class="headerlink" title="ADC数模转换"></a>ADC数模转换</h2><p>ADC就是一种可以把连续的电信号转化为数字形式的离散信号的方式，像32单片机对ADC有着很好的支持，有专门的功能支持ADC的实现。</p>
<p>先放张ADC的配置过程图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/31E50140E4B6864A74B390B588510B62.jpg" alt="31E50140E4B6864A74B390B588510B62"></p>
<p>首先还是先选择输入的模式，可以选GPIO的信号也可以选择内部外设的温度传感器作为信号源，这个对应的就是ADC的channel的选择，然后就进入规则组和注入组的配置还有一些基本的参数配置，这些也都是在官方库中以结构体的形式传递参数。然后可以选择模拟看门狗的配置，可以达到一定的值以后触发看门狗，挺方便的，也可以继续接入中断，触发中断去执行其他任务。</p>
<p>下面的触发控制可以选择定时器触发或者中断触发，也可以选择软件触发，我们使用的就是软件触发，RCC则用的是内部72mzh的时钟。</p>
<p>下面是具体代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_Initstructure;</span><br><span class="line">	GPIO_Initstructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_Initstructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_Initstructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_Initstructure);		<span class="comment">//GPIO初始化</span></span><br><span class="line">	</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//选择采样时间和频道，这里的频道设置要慎重选择，不同频道对应不用的io口</span></span><br><span class="line">	</span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;<span class="comment">//是否连续采样，就是不断循环读取值</span></span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<span class="comment">//选择触发源，这里的noone就是软件触发</span></span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;<span class="comment">//ADC模式，这里的是单ADC模式</span></span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>;<span class="comment">//转换通道设置，就是你有多少条数据需要ADC转换</span></span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = DISABLE;<span class="comment">//扫描模式设置，选择扫描一个通道还是多个通道</span></span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);		<span class="comment">//ADC使能</span></span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);<span class="comment">//重置校验器</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)==SET);<span class="comment">//等待重置完成</span></span><br><span class="line">	ADC_StartCalibration(ADC1);<span class="comment">//启用校验器</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1)==SET);			<span class="comment">//等待校验完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);		<span class="comment">//软件触发</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);</span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);		<span class="comment">//读取转换的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大致如上了，这些代码就可以实现对PA0口的输入的电压进行数模转换，如果想要调成其他io口，就需要翻手册，不同的对应的io口都有不同的channel值设置。</p>
<p>如果想对多个io口进行数模转化，也不难，对它们进行扫描就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">uint8_t</span> ADC_Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);</span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以将AD数据的读取函数设置成这个样子就可以了，在主函数里面依次读取不同channel的数值，并且储存到变量里面就可以了。</p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA是一种计算机系统中的数据传输技术，允许某些硬件子系统（如硬盘控制器、网络接口卡、声卡等）在不依赖中央处理器（CPU）的情况下，直接与系统的主内存（RAM）进行数据交换。这种技术的主要目的是<strong>提高数据传输效率</strong> ，减轻CPU的负担。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-09_15-11-49.png" alt="PixPin_2025-04-09_15-11-49"></p>
<p>这是DMA的核心原理图，我们需要配置的基本都在这个上面了。</p>
<p>下面是一个DMA使用案列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> Addra,<span class="type">uint32_t</span> Addrb,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;	</span><br><span class="line"></span><br><span class="line">	MyDMA_Size = Size;</span><br><span class="line">	</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = Size;<span class="comment">//自动重装</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//方向设置，从外设作为出发地址</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Enable;<span class="comment">//设置为软件触发</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = Addrb;<span class="comment">//存储器地址</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;<span class="comment">//存储器的数据宽度</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Normal;<span class="comment">//循环模式，有单次和无限循环的区别</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = Addra;<span class="comment">//外设地址</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//外设的数据宽度</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="comment">//外设地址是否自增</span></span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;<span class="comment">//DMA级别设置，用于多个DMA之间选择先后</span></span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);		<span class="comment">//改变传输计数器的值，需要先失能DMA然后再使能才能生效</span></span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1)==RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);		<span class="comment">//一旦查看了DMA的状态值就要记得清除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是主函数配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">#include &quot;OLED.h&quot;</span><br><span class="line">#include &quot;Mydma.h&quot;</span><br><span class="line">uint8_t dataa[]=&#123;1,2,3,4&#125;;</span><br><span class="line">uint8_t datab[]=&#123;0,0,0,0&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	MyDMA_Init((uint32_t)dataa,(uint32_t)datab,4);</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;	</span><br><span class="line">		dataa[0]++;</span><br><span class="line">		dataa[1]++;</span><br><span class="line">		dataa[2]++;</span><br><span class="line">		dataa[3]++;</span><br><span class="line">		OLED_ShowHexNum(1,1,dataa[0],2);</span><br><span class="line">		OLED_ShowHexNum(1,4,dataa[1],2);</span><br><span class="line">		OLED_ShowHexNum(1,7,dataa[2],2);</span><br><span class="line">		OLED_ShowHexNum(1,10,dataa[3],2);</span><br><span class="line">		OLED_ShowHexNum(2,1,datab[0],2);</span><br><span class="line">		OLED_ShowHexNum(2,4,datab[1],2);</span><br><span class="line">		OLED_ShowHexNum(2,7,datab[2],2);</span><br><span class="line">		OLED_ShowHexNum(2,10,datab[3],2);</span><br><span class="line">		Delay_ms(1000);</span><br><span class="line">		MyDMA_Transfor();</span><br><span class="line">		OLED_ShowHexNum(3,1,dataa[0],2);</span><br><span class="line">		OLED_ShowHexNum(3,4,dataa[1],2);</span><br><span class="line">		OLED_ShowHexNum(3,7,dataa[2],2);</span><br><span class="line">		OLED_ShowHexNum(3,10,dataa[3],2);</span><br><span class="line">		OLED_ShowHexNum(4,1,datab[0],2);</span><br><span class="line">		OLED_ShowHexNum(4,4,datab[1],2);</span><br><span class="line">		OLED_ShowHexNum(4,7,datab[2],2);</span><br><span class="line">		OLED_ShowHexNum(4,10,datab[3],2);</span><br><span class="line">		Delay_ms(1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样就可以清楚的看到DMA的传输数据的过程。</p>
<h2 id="DMA与ADC相结合"><a href="#DMA与ADC相结合" class="headerlink" title="DMA与ADC相结合"></a>DMA与ADC相结合</h2><p>在实际使用过程中，因为ADC数模转换的速度非常快，而且如果用的是规则组，只有一个寄存器来读取数据，所以我们需要DMA来帮助我们快速转运数据到其他位置，防止数据被覆盖而丢失。</p>
<p>虽然ST并没有写单个ADC通道转换完成，我们只能拿到一系列的ADC通道转换完成的返回，但是ST非常贴心的给出了ADC和DMA的交互通道，可以做到每个通道一转换完成，就可以通知DMA进行数据转移。</p>
<p>下面是一个使用案例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint16_t</span> data[<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_Initstructure;</span><br><span class="line">	GPIO_Initstructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_Initstructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">	GPIO_Initstructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_Initstructure);</span><br><span class="line">	</span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>;</span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = ENABLE;</span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line"></span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>;<span class="comment">//自动重装（因为ADC开启了两个通道，所以DMA也转运两次）</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//方向</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Disable;<span class="comment">//因为是硬件触发，所以设置disable</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)&amp;data[<span class="number">0</span>];</span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	ADC_DMACmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)==SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1)==SET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Getvalue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">2</span>);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1)==RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个代码的实现就需要把**AD_Getvalue()**这个函数放到while1里面不断循环设置DMA和软件触发ADC。</p>
<p>得到的数据就全部存在了data的数组里面，把这个数组在.h文件里面声明一下，就可以在主函数直接读取并且使用了。</p>
<p>其实还可以做一些配置，比如修改一下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br></pre></td></tr></table></figure>



<p>1.把这个函数放在MyDMA_Init()里面；</p>
<p>2.然后将ADM和DMA都改成自动的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;</span><br></pre></td></tr></table></figure>



<p>这样子只要在调用一次MyDMA_Init()函数，就可以先软件触发ADC，然后ADC和DMA无限循环监测并转移数据了。</p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>先介绍几个通信的方式和概念吧。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-11-00-10-44-728_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-11-00-10-44-728_tv.danmaku.bil"></p>
<p>解释一些概念：</p>
<ol>
<li>双工：这是根据通信双方的传输方式决定的，分为单工，全双工和半双工，其中，单工就是只有单向通信，半双工指的是可以双向通信，但不能同时进行通信，而全双工则是可以同时进行双向通信。</li>
<li>时钟：异步指的是双方的通信不需要额外的时钟线，就是不需要时钟来同步数据传输，而同步则是需要时钟。</li>
<li>电平：就是指双方通信区分高低电平的方法，单端则是根据他们相对于同一个电平来区分，这个标准电平通常是GND，而差分电平就是通过两个电平的差分值来判断高低电平。差分的方式比较稳定。</li>
</ol>
<p>这些都是一些比较常见的单片机传输协议，各有各的优点和特色吧。</p>
<h3 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h3><p>USART就是我们通常所说的串口通信。把hex文件烧录到单片机中，就使用了串口通信，和ch340这个usb转串口通信的芯片。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-11-00-28-17-826_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-11-00-28-17-826_tv.danmaku.bil"></p>
<p>这是串口的一些参数和时序图，我们需要设置合适的参数。</p>
<p>一般选用的模式都是9字符带校验位的模式或者8字符不带校验位的模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-12_01-05-08.png" alt="PixPin_2025-04-12_01-05-08"></p>
<p>这是USART的配置流程图，其中的TX和RX都是有与之相对应的GPIO口的，这些都是手册里写死的。</p>
<p>最开始都是先开启内部时钟并设置好分频以供发送和接收器的使用，并且发送和接受都有一个寄存器做好了缓存，避免数据覆盖，只有当数据完全写入或者读取后，才会写入新的数据。</p>
<h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>这是发送数据的函数代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//设置波特率</span></span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//关闭硬件流配置</span></span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx;<span class="comment">//选择模式</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;<span class="comment">//设置校验位</span></span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位设置</span></span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//设置数据大小</span></span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> byte)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(USART1,byte);</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *<span class="built_in">array</span>,<span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint16_t</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(<span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(String[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>接收和发送大致相同，就改了几行的配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;<span class="comment">//加上RX模式</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主函数里的while1里面再这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		data = USART_ReceiveData(USART1);</span><br><span class="line">	&#125;</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,data,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<p>就可以实现对接收到的数据进行读取的操作了。</p>
<p>还可以使用中断，只需要加上这行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br></pre></td></tr></table></figure>

<p>并且配置好nvic就可以使用中断了。</p>
<h3 id="USART发送接收数据包"><a href="#USART发送接收数据包" class="headerlink" title="USART发送接收数据包"></a>USART发送接收数据包</h3><p>前文的发送和接收的都是只能发送和接收单字节，下面将实现对一个数据包的发送和接收。因为发送比较简单，拼出发送一个字符串就可以了。所有主要写的还是接收数据包。</p>
<p>首先先说明一下数据包。</p>
<p>数据包有两种形式，一个是固定长度，还有一个是不固定长度，但是不论哪种形式，都需要定义包头和包尾，发送的内容也可以是hex模式（即16进制的模式），和文本模式，即发送已经编码后的文本。</p>
<p>下面是一张不固定长度的文本模式的数据包构造，可以看到图中的包头是“ @ ” ， 包尾是 “\r\n”（这是windows系统的换行符） ，图中也写明了如何定义接收的函数，就是通过状态机的思想，通过不同的状态来控制整个的接收流程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-14-11-20-55-840_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-14-11-20-55-840_tv.danmaku.bil"></p>
<p>下面是一个程序实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint8_t</span> USARTStatu;</span><br><span class="line"><span class="type">uint8_t</span> RXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> TXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;</span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">USART_Getflag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(USARTStatu==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		USARTStatu=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState=<span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> pRxState=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">uint8_t</span> Rxdata = USART_ReceiveData(USART1);</span><br><span class="line">		<span class="keyword">if</span>(RxState==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="number">0xFF</span>)</span><br><span class="line">				RxState=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			RXPack[pRxState] = Rxdata;</span><br><span class="line">			pRxState++;</span><br><span class="line">			<span class="keyword">if</span>(pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="number">0xFE</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">0</span>;</span><br><span class="line">				USARTStatu=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		USART_ClearITPendingBit(USART1,USART_IT_RXNE);<span class="comment">//清楚标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个固定长度的hex数据包的接收，其中包头是 “0xFF” ，包尾是 “0xFE” 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(USART_Getflag()==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXPack[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">3</span>,RXPack[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">5</span>,RXPack[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,RXPack[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在主函数的while循环里执行这条语句，就可以不断读取接收到的数据，并且显示在oled屏幕上了。</p>
<p>还有无固定大小文本模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint8_t</span> USARTStatu=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> RXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> TXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;</span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState=<span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> pRxState=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">uint8_t</span> Rxdata = USART_ReceiveData(USART1);</span><br><span class="line">		<span class="keyword">if</span>(RxState==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="string">&#x27;@&#x27;</span> &amp;&amp; USARTStatu==<span class="number">0</span>)</span><br><span class="line">				RxState=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">				RxState=<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				data[pRxState] = Rxdata;</span><br><span class="line">				pRxState++;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Rxdata==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			RxState = <span class="number">0</span>;</span><br><span class="line">			data[pRxState] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			pRxState=<span class="number">0</span>;</span><br><span class="line">			USARTStatu=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个有效地防止了数据包的错位，直接引入了USARTStatu的判定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	Serial_Init();</span><br><span class="line">	LED_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(USARTStatu==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,data);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(data,<span class="string">&quot;LEDON&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				LED1_ON();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(data,<span class="string">&quot;LEDOF&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				LED1_OFF();</span><br><span class="line">			&#125;</span><br><span class="line">			USARTStatu=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中做一下数据的处理，就可以很方便的完成电脑输入命令然后对里面的内容进行控制了。</p>
<h3 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h3><p>IIC是一种通信协议，是一个同步半双工通信，用途非常广，只需要SCL和SDA两根线就可以完成数据的同步传输，因为是同步的协议，所以可以随时开始通信也可以随时停止通信，而且可以一个主多从，一个主机可以和多个从机进行交互。</p>
<p>先介绍一下基本的通信流程吧。</p>
<p>一开始初始因为有一个上拉电阻，处于一个弱上拉的状态，所以呈现的状态是高电平。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_11-43-18.png" alt="PixPin_2025-04-23_11-43-18"></p>
<p>这是开始和结束的时序图，当主机准备开始通信的时候，就会在保持SCL高电平的同时，拉低SDA。主机在准备结束通信的时候，就会在SCL保持高电平的时候，回弹SDA。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_12-07-23.png" alt="PixPin_2025-04-23_12-07-23"></p>
<p>这是发送一个字节的时序。  在SCL在低电平的时间，主机快速把数据放在SDA上，等到SCL回弹到高电平之后，从机就会读取SDA的电平状态来判断0还是1，然后主机再拉低SCL，如此反复执行8次，就可以发送一个字节的时序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_12-25-47.png" alt="PixPin_2025-04-23_12-25-47"></p>
<p>这是接收一个字节的时序。在SCL在低电平的时间，从机快速把数据放在SDA上，主机再把SCL置为高电平并且此时读取SDA的电平状态判断是0还是1，也是循环8次，接收一个字节（主机在接收前需要回弹SDA）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_13-17-07.png" alt="PixPin_2025-04-23_13-17-07"></p>
<p>这是发送应答和接收应答的时序。当每完成一个字节的数据传输以后，就会开启应答来确认一下是否接收到了数据。其中，在主机接收应答前，需要把SDA的电平拉下来，然后从机如果接收到了数据，需要立马将SDA回弹至高电平，只有这样才算接收到了数据。</p>
<p>这些就是IIC通信的基本单元，下面是一个完整的IIC发送流程：</p>
<ol>
<li>主机先发送开始信号。</li>
<li>主机继续发送选择从机的地址码加上发送还是接收选择，其中，地址码通常是一个7位的二进制数据，然后模式选择是选择发送还是接收，其中0表示写，1表示读，拼接起来就是一个8位一个字节的数据。</li>
<li>然后就是发送数据，发送一个字节的数据，从机依次接收数据。（这个数据可以是需要写入的地址或者写入的数据，这个具体看从机的要求）</li>
<li>从机发送ack表示已经接收到了数据。</li>
<li>最后主机可以选择发送stop终止信号。</li>
</ol>
<p>下面是一个完整的IIC接收流程：</p>
<ol>
<li>主机先发送开始信号。</li>
<li>一样的主机发送从机的地址码加一个0。</li>
<li>发送你要读取的寄存器的地址，从机会应答。</li>
<li>重复起始条件。</li>
<li>发送从机地址加1，切换到读的模式。</li>
<li>从机控制SDA线，主机读取SDA线以获取数据，如果需要继续发送，主机发送ACK就行了，如果终止发送，主机发送NACK。</li>
<li>最后主机发送stop终止信号。</li>
</ol>
<h4 id="软件模拟IIC"><a href="#软件模拟IIC" class="headerlink" title="软件模拟IIC"></a>软件模拟IIC</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_W_SCL</span><span class="params">(<span class="type">uint8_t</span> Bitvalue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB,GPIO_Pin_10,(BitAction)Bitvalue);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_W_SDA</span><span class="params">(<span class="type">uint8_t</span> Bitvalue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB,GPIO_Pin_11,(BitAction)Bitvalue);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Myi2c_R_SDA</span><span class="params">()</span><span class="comment">//封装了一些基本的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> Bitvalue;</span><br><span class="line">	Bitvalue = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> Bitvalue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_SetBits(GPIOB,GPIO_Pin_10 | GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SDA(<span class="number">0</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">0</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2c_sendbyte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Myi2c_W_SDA(Byte &amp; (<span class="number">0x80</span>&gt;&gt;i));</span><br><span class="line">		Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">		Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2c_receivebyte</span><span class="params">()</span><span class="comment">//发送一个字节的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i,Byte = <span class="number">0x00</span>;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(Myi2c_R_SDA() == <span class="number">1</span>)&#123;Byte |= (<span class="number">0x80</span>&gt;&gt;i);&#125;;</span><br><span class="line">		Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2c_sendack</span><span class="params">(<span class="type">uint8_t</span> ackbit)</span></span><br><span class="line">&#123;	</span><br><span class="line">		Myi2c_W_SDA(ackbit);</span><br><span class="line">		Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">		Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2c_receiveack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ackbit;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">	ackbit = Myi2c_R_SDA();</span><br><span class="line">	Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> ackbit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是软件模拟IIC的基本函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	MyI2C_Init();</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0xD0</span>);</span><br><span class="line">	<span class="type">uint8_t</span> ack = MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">	OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,ack,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个简单的使用例子，发送了选择从机的字节后接收回应，正确的显示应该是000。</p>
<h5 id="IIC加MPU6050"><a href="#IIC加MPU6050" class="headerlink" title="IIC加MPU6050"></a>IIC加MPU6050</h5><p>MPU6050是一个比较出名的运动处理传感器，它有着三轴陀螺仪传感器和三轴加速度传感器，可以测算出芯片的姿态，应用非常广泛，其中它的通信方式就是通过IIC与主机进行通信。</p>
<p>下面是基于上节所写的IIC基本代码而完成的MPU6050库函数编写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">#include &quot;myiic.h&quot;</span><br><span class="line">#include &quot;MPU6050_Reg.h&quot;</span><br><span class="line">#define MPU6050_ADDRESS 0xD0</span><br><span class="line">void MPU6050_WriteReg(uint8_t RegAddress,uint8_t Data)</span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(MPU6050_ADDRESS);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(RegAddress);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(Data);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t MPU6050_ReadReg(uint8_t RegAddress)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t Data;</span><br><span class="line">	</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(MPU6050_ADDRESS);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(RegAddress);</span><br><span class="line">	MyI2c_receiveack();//第一次发送，将地址指针移动到想要读取数据的位置</span><br><span class="line">	</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(MPU6050_ADDRESS | 0x01);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Data = MyI2c_receivebyte();</span><br><span class="line">	MyI2c_sendack(1);</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">	</span><br><span class="line">	return Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MPU6050_Init()</span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_Init();</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_1,0x01);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_2,0x00);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_SMPLRT_DIV,0x09);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_CONFIG,0x06);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_GYRO_CONFIG,0x18);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,0x18);//根据手册写的基本的MPU6050的寄存器配置</span><br><span class="line">&#125;</span><br><span class="line">void MPU6050_Getdata(int16_t *AccX,int16_t *AccY,int16_t *AccZ,int16_t *GyroX,int16_t *GyroY,int16_t *GyroZ)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t DataH,DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">	*AccX = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">	*AccY = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">	*AccZ = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">	*GyroX = (DataH&lt;&lt;8) | DataL;</span><br><span class="line"></span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">	*GyroY = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">	*GyroZ = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">&#125;//读取对应的寄存器的值</span><br></pre></td></tr></table></figure>



<p>调用的话就在主函数里面声明这些变量，然后while里面不断获取数据就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	MPU6050_Init();</span><br><span class="line">	<span class="type">int16_t</span> ax,ay,az,gx,gy,gz;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MPU6050_Getdata(&amp;ax,&amp;ay,&amp;az,&amp;gx,&amp;gy,&amp;gz);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,ax,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,ay,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,az,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,gx,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,gy,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,gz,<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子就可以在OLED上看到不断打印出的数据了。</p>
<h4 id="硬件模拟IIC"><a href="#硬件模拟IIC" class="headerlink" title="硬件模拟IIC"></a>硬件模拟IIC</h4><p>stm32f103系列自带了有两个IIC的外设，对应的是IIC1和IIC2，硬件控制比软件模拟就相对舒服很多了，库函数也提供了很成熟的函数支持IIC通信，与GPIO等常用外设初始化一样，IIC的初始化也是通过构造结构体并且传入数值来进行设置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-24-09-00-29-587_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-24-09-00-29-587_tv.danmaku.bil"></p>
<p>这是IIC的配置流程，基本上按照流程图配置完寄存器就可以了。</p>
<p>IIC外设的寄存器分为三种，第一个是CR，控制寄存器，就是对IIC外设进行基本设置的寄存器，第二个是DR，数据寄存器，就是存储IIC接收到的数据的寄存器，不管是发送还是接收数据，都会用到这个DR寄存器，第三个是SR，状态寄存器，专门用来读取IIC的状态的，方便对IIC的工作做出基本的判断和调控。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-25_13-22-47.png" alt="PixPin_2025-04-25_13-22-47"></p>
<p>这是发送时序的流程图，其中EVx就是可以通过状态寄存器SR进行读取的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-25_13-23-07.png" alt="PixPin_2025-04-25_13-23-07"></p>
<p>这是接收器的时序图，写代码按照这个图上的流程进行基本的配置就可以了，st官方的库函数已经封装好了相对成熟的函数方便我们进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT) != SUCCESS);</span><br><span class="line">	I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) != SUCCESS);</span><br><span class="line">	I2C_SendData(I2C2,RegAddress);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) != SUCCESS);</span><br><span class="line">	I2C_SendData(I2C2,Data);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) != SUCCESS);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) != SUCCESS);</span><br><span class="line">	I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> Data;</span><br><span class="line">	I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT) != SUCCESS);</span><br><span class="line">	I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) != SUCCESS);</span><br><span class="line">	I2C_SendData(I2C2,RegAddress);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) != SUCCESS);</span><br><span class="line">	I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT) != SUCCESS);	</span><br><span class="line">	I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Receiver);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) != SUCCESS);</span><br><span class="line">	I2C_AcknowledgeConfig(I2C2,DISABLE);</span><br><span class="line">	I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_RECEIVED) != SUCCESS);</span><br><span class="line">	Data = I2C_ReceiveData(I2C2);</span><br><span class="line">	I2C_AcknowledgeConfig(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	I2C_Init();</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	I2C_InitTypeDef I2C_InitStruct;</span><br><span class="line">	I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">	I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">	I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</span><br><span class="line">	I2C_InitStruct.I2C_ClockSpeed = <span class="number">10000</span>;</span><br><span class="line">	I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_16_9;</span><br><span class="line">	I2C_InitStruct.I2C_OwnAddress1 = <span class="number">0x00</span>;</span><br><span class="line">	I2C_Init(I2C2,&amp;I2C_InitStruct);</span><br><span class="line">	</span><br><span class="line">	I2C_Cmd(I2C2,ENABLE);</span><br><span class="line">	</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_CONFIG,<span class="number">0x06</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_GYRO_CONFIG,<span class="number">0x18</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是针对上一节的软件模拟IIC实现MPU6050的读取的优化，如果担心while会陷入死循环的话，可以再封装一个等待函数，可以尝试10000–这种操作，如果超时就强行退出。</p>
<h3 id="spi通信"><a href="#spi通信" class="headerlink" title="spi通信"></a>spi通信</h3><p>spi通信有四根线，分别是MOSI，MOSO，SLK，SS。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MOSI</td>
<td align="center">主机发送</td>
</tr>
<tr>
<td align="center">MOSO</td>
<td align="center">主机接收</td>
</tr>
<tr>
<td align="center">SLK</td>
<td align="center">时钟线，由主机完全控制</td>
</tr>
<tr>
<td align="center">SS</td>
<td align="center">设备选择线，低电平表示选中设备</td>
</tr>
</tbody></table>
<p>spi相对iic来说要简单一些，因为它的线比较多，所以没有这么多限制条件，下图是spi通信的原理，本质上发送和接收是一体的，同时发送同时接收，就是通过一位一位的移，差不多是一个循环模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-27-09-17-16-594_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-27-09-17-16-594_tv.danmaku.bil"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-30_10-55-23.png" alt="PixPin_2025-04-30_10-55-23"></p>
<p>这是最常用的模式0的时序，模式0就是上升沿读取数据，下降沿准备数据，并且SCK空闲的时候为低电平，总共有四种模式选择，就是CPOL和CPHA的不同组合，最常用的还是模式0。</p>
<h4 id="软件模拟spi"><a href="#软件模拟spi" class="headerlink" title="软件模拟spi"></a>软件模拟spi</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_ss</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_sck</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_5,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_mosi</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_7,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">myspi_r_miso</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">	myspi_w_sck(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">myspi_swapbyte</span><span class="params">(<span class="type">uint8_t</span> bytesend)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> received_byte = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送最高位</span></span><br><span class="line">        myspi_w_mosi((bytesend &amp; <span class="number">0x80</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 拉高时钟，从设备在上升沿采样MOSI数据</span></span><br><span class="line">        myspi_w_sck(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取MISO数据（在时钟高电平期间有效）</span></span><br><span class="line">        received_byte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (myspi_r_miso() == <span class="number">1</span>) &#123;</span><br><span class="line">            received_byte |= <span class="number">0x01</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拉低时钟，准备下一位</span></span><br><span class="line">        myspi_w_sck(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 准备发送下一位</span></span><br><span class="line">        bytesend &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> received_byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过myspi_swapbyte函数，就可以交换一个字节，以达到通信的效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myspi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;w25q64_ins.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_Init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_readid</span><span class="params">(<span class="type">uint8_t</span> *MID,<span class="type">uint16_t</span> *DID)</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_JEDEC_ID);</span><br><span class="line">	*MID = myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	*DID = myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	*DID &lt;&lt;=<span class="number">8</span>;</span><br><span class="line">	*DID |= myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	myspi_stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_write_enable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_WRITE_ENABLE);</span><br><span class="line">	myspi_stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_wait_busy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_READ_STATUS_REGISTER_1);</span><br><span class="line">	<span class="keyword">while</span>((myspi_swapbyte(W25Q64_DUMMY_BYTE)&amp; <span class="number">0x01</span>)==<span class="number">0x01</span>);</span><br><span class="line">	myspi_stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_pageprogram</span><span class="params">(<span class="type">uint32_t</span> address,<span class="type">uint8_t</span> *data,<span class="type">uint16_t</span> count)</span></span><br><span class="line">&#123;	</span><br><span class="line">	w25q64_write_enable();</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_PAGE_PROGRAM);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	myspi_swapbyte(address);</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		myspi_swapbyte(data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	myspi_stop();</span><br><span class="line">	w25q64_wait_busy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_sector_erase</span><span class="params">(<span class="type">uint32_t</span> address)</span></span><br><span class="line">&#123;	</span><br><span class="line">	w25q64_write_enable();</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	myspi_swapbyte(address);</span><br><span class="line">	myspi_stop();</span><br><span class="line">	w25q64_wait_busy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_readdata</span><span class="params">(<span class="type">uint32_t</span> address,<span class="type">uint8_t</span> *data,<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_READ_DATA);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	myspi_swapbyte(address);</span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data[i] = myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	&#125;</span><br><span class="line">	myspi_stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是基于spi底层所写的关于w25q64的使用函数封装，spi通信很多都是按照对应的外设发送设定好的命令来做一些交互。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;w25q64.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> MID;</span><br><span class="line"><span class="type">uint16_t</span> DID;</span><br><span class="line"><span class="type">uint8_t</span> dataw[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> datar[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	w25q64_Init();</span><br><span class="line">	w25q64_readid(&amp;MID,&amp;DID);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,MID,<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>,<span class="number">5</span>,DID,<span class="number">4</span>);</span><br><span class="line">	w25q64_sector_erase(<span class="number">0x000000</span>);</span><br><span class="line">	w25q64_pageprogram(<span class="number">0x0000000</span>,dataw,<span class="number">4</span>);</span><br><span class="line">	w25q64_readdata(<span class="number">0x000000</span>,datar,<span class="number">4</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,datar[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,datar[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,datar[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,datar[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是调用方法，可以看到数据成功被移入w25q64中，并且断电也没有丢失。</p>
<h4 id="硬件模拟spi"><a href="#硬件模拟spi" class="headerlink" title="硬件模拟spi"></a>硬件模拟spi</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-05-02_00-21-49.png" alt="PixPin_2025-05-02_00-21-49"></p>
<p>stm32的库函数已经帮我们处理好了很多细节上的配置，基本上按照流程图加结构体配置，就可以使用硬件模拟spi了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_ss</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5| GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	SPI_InitTypeDef SPI_InitStruct;</span><br><span class="line">	SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;</span><br><span class="line">	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;</span><br><span class="line">	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;</span><br><span class="line">	SPI_InitStruct.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">	SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;</span><br><span class="line">	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;</span><br><span class="line">	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;</span><br><span class="line">	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;</span><br><span class="line">	SPI_Init(SPI1, &amp;SPI_InitStruct);</span><br><span class="line">	</span><br><span class="line">	SPI_Cmd(SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">myspi_swapbyte</span><span class="params">(<span class="type">uint8_t</span> bytesend)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != SET);</span><br><span class="line">    SPI_I2S_SendData(SPI1, bytesend);</span><br><span class="line">    <span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != SET);</span><br><span class="line">    <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是硬件模拟spi的底层代码，与其他外设大同小异，都是结构体配置还有什么状态读取之类的。</p>
<h3 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h3><p>can通信在四大通信里面算是最难的一款了通信协议了，它兼具IIC和USART通信的一些特点，一样有TX和RX两根线，没有时钟线，全双工，但是又可以一对多进行数据通信，多用于板子间的数据交流。</p>
<p>而且can通信有非常完善的数据纠错等等功能，可以很好地处理异常，错误等各种情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/BB395BB43C68A69FAFFD812AB538B50A.jpg" alt="BB395BB43C68A69FAFFD812AB538B50A"></p>
<p>这是CAN总线的几种帧格式，用的最多的还是数据帧和遥控帧。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/64F3FE0F7788F7928F7336A3275267F7.jpg" alt="64F3FE0F7788F7928F7336A3275267F7"></p>
<p>这是can通信的时序，分为标准格式和扩展格式两种，标准格式和扩展格式的区别是扩展格式的ID可以更长一点，扩展格式id有29位。</p>
<p>不过平常还是使用标准格式比较多，毕竟没这么多设备。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/64570E254949F2F00597014011FA048A.jpg" alt="64570E254949F2F00597014011FA048A"></p>
<p>可以对着上图的简介表理解时序图，can通信每一次发送最多可以发送8字节。</p>
<p>还有就是can通信的仲裁段，如果碰到两个设备同时准备发送通信，就会进入仲裁阶段，仲裁的依据主要就是id号的大小，id号越小的仲裁获胜的可能性越大，并且标准大于扩展，数据帧大于遥控帧，这里的位数设计非常巧妙，很好地兼容了标准格式和扩展格式两种情况。</p>
<p>下面是一些can总线为我传输不出错更严谨的独特机制。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/DA7195F27407D4D7F1D9D27E8227B05F.jpg" alt="DA7195F27407D4D7F1D9D27E8227B05F"></p>
<p>首先是位填充，为了避免发送大量相同的数据造成误判的可能情况，所以设计了位填充的机制，就是每发5个相同电平时，会自动在后面追加一个相反电平的填充位，具体机制可以看上图。</p>
<p>这个可以防止发送大量相同的电平，比如连续发送隐性1，被误判为进入了空闲状态，（连续发送11个隐性1就是进入了空闲状态，11位其实就是时序图中的ack界定符加上7的个结束位加上3个的帧间隔）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/631928DB379DFC98E67C46FB3CA2C9BA.jpg" alt="631928DB379DFC98E67C46FB3CA2C9BA"></p>
<p>还有就是关于时序上的一些知识点，其中每一个位的采集又可以细分为4个部分，其中ss是同步段，就是每次一开始发数据，每个设备都会利用ss来进行同步，确保自己的初始时钟是正确的，这就是硬同步。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/0872D0C959DE12E5DAC9E9ED236A4335.jpg" alt="0872D0C959DE12E5DAC9E9ED236A4335"></p>
<p>pts是传播时间段，这个通常有硬件问题而配置的，毕竟传输过来还需要时间。</p>
<p>然后就是pbs1和pbs2，这两个就是控制采样位的核心了，也是再同步。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/2ED55889A566C8C77329F97A8C0A7B78.jpg" alt="2ED55889A566C8C77329F97A8C0A7B78"></p>
<p>就是通过设置sjw，sjw会在通信的过程中，保证采样点在pbs1和pbs2之间，不过这些都是硬件电路自动完成的，这就是can通信的再同步机制。</p>
<h4 id="硬件调用CAN通信"><a href="#硬件调用CAN通信" class="headerlink" title="硬件调用CAN通信"></a>硬件调用CAN通信</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">void Mycan_Init()</span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);	</span><br><span class="line">	</span><br><span class="line">	CAN_InitTypeDef CAN_InitStruct;</span><br><span class="line">	CAN_InitStruct.CAN_ABOM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_AWUM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_BS1 = CAN_BS1_2tq;</span><br><span class="line">	CAN_InitStruct.CAN_BS2 = CAN_BS2_3tq;</span><br><span class="line">	CAN_InitStruct.CAN_Mode = CAN_Mode_LoopBack;</span><br><span class="line">	CAN_InitStruct.CAN_NART = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_Prescaler = 48;</span><br><span class="line">	CAN_InitStruct.CAN_RFLM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_SJW = CAN_SJW_2tq;</span><br><span class="line">	CAN_InitStruct.CAN_TTCM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_TXFP = DISABLE;</span><br><span class="line"></span><br><span class="line">	CAN_Init(CAN1,&amp;CAN_InitStruct);</span><br><span class="line">	</span><br><span class="line">	CAN_FilterInitTypeDef CAN_FilterInitStruct;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterActivation = ENABLE;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdHigh = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdLow = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdHigh = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdLow = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMode = CAN_FilterMode_IdMask;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterNumber = 0;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterScale = CAN_FilterScale_32bit;</span><br><span class="line">	CAN_FilterInit(&amp;CAN_FilterInitStruct);</span><br><span class="line">&#125;</span><br><span class="line">void Mycan_transmit(uint32_t id,uint8_t length,uint8_t *data)</span><br><span class="line">&#123;</span><br><span class="line">	CanTxMsg TxMessage;</span><br><span class="line">	for(uint8_t i=0;i&lt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		TxMessage.Data[i] = data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	TxMessage.DLC = length;</span><br><span class="line">	TxMessage.ExtId = id;</span><br><span class="line">	TxMessage.IDE = CAN_Id_Standard;</span><br><span class="line">	TxMessage.RTR = CAN_RTR_DATA;</span><br><span class="line">	TxMessage.StdId = id;</span><br><span class="line">	uint8_t transmitmailbox = CAN_Transmit(CAN1,&amp;TxMessage);</span><br><span class="line">	while(CAN_TransmitStatus(CAN1,transmitmailbox)!=CAN_TxStatus_Ok);</span><br><span class="line">&#125;</span><br><span class="line">uint8_t Mycan_receiveflag()</span><br><span class="line">&#123;</span><br><span class="line">	if(CAN_MessagePending(CAN1,CAN_FIFO0)&gt;0)</span><br><span class="line">		return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void Mycan_receive(uint32_t *id,uint8_t *length,uint8_t *data)</span><br><span class="line">&#123;	</span><br><span class="line">	CanRxMsg RxMessage;</span><br><span class="line">	CAN_Receive(CAN1,CAN_FIFO0,&amp;RxMessage);</span><br><span class="line">	if(RxMessage.IDE==CAN_Id_Standard)</span><br><span class="line">	&#123;</span><br><span class="line">		*id=RxMessage.StdId;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		*id=RxMessage.ExtId;</span><br><span class="line">	&#125;</span><br><span class="line">	if(RxMessage.RTR==CAN_RTR_DATA)</span><br><span class="line">	&#123;</span><br><span class="line">		*length = RxMessage.DLC;</span><br><span class="line">		for(uint8_t i=0;i&lt;*length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			data[i]=RxMessage.Data[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">//	RxMessage.FMI = ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里也只是测试了一下回环通信，测试一下软件有没有问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">lca</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/">http://example.com/2024/12/07/32单片机系列/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Lucky</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/07/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5%E4%B8%8A%E5%AE%89%E8%A3%85stlink%E9%A9%B1%E5%8A%A8/" title="小米平板5上安装stlink驱动"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">小米平板5上安装stlink驱动</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/11/15/python%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/" title="python人脸检测"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">python人脸检测</div></div><div class="info-2"><div class="info-item-1">python人脸检测最近突然对图像识别有了点兴趣，便开始找一些识别的库，我这里采用的是python+opencv的方法，利用opencv内置的人脸检测库，可以比较方便快速地检测出人脸，学的很浅，也就图一乐。记录下来也只是为了以后便于回忆。 将图片转化为灰度图片12345678import cv2 as cvimg = cv.imread(&#x27;testlca.jpg&#x27;)cv.imshow(&#x27;test&#x27;, img)gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)cv.imshow(&#x27;gray&#x27;, gray_img)cv.imwrite(&#x27;testlca_gray.jpg&#x27;,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/12/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/" title="单片机实践系列合集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="info-item-2">单片机实践系列合集</div></div><div class="info-2"><div class="info-item-1">此板块用来记录一些成熟的单片机程序矩阵键盘密码锁通过矩阵键盘输入数字，再调用lcd1602提供显示功能，来实现简单的验证密码的功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;REGX52.H&gt;#include &quot;delay.h&quot;#include &quot;lcd1602.h&quot;#include &quot;Martrixkey.h&quot;           //引入一系列的库unsigned int password,count;		//定义了密码变量跟计数变量unsigned char KeyNum;			//定义键码void...</div></div></div></a><a class="pagination-related" href="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/" title="51单片机系列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-03</div><div class="info-item-2">51单片机系列</div></div><div class="info-2"><div class="info-item-1">51单片机系列此文章记录我学单片机进程，以及所写的代码集合，当作笔记和备份吧，以后可以温习用。 目前正在学的是51单片机，普中A2版本。 先上张原理图  再来张十六进制换算表  LED模块最简单的点灯代码123456789#include &lt;REGX52.H&gt;void main()&#123;	P2 = 0xFE;	while(1)	&#123;&#125;&#125;    控制点灯时间代码通过软件内置的时间延迟计算生成函数，来控制时间。  1234567891011121314151617181920212223242526272829#include &lt;REGX52.H&gt;#include &lt;INTRINS.H&gt;void Delay500ms()		//@12.000MHz&#123;	unsigned char i, j, k;	_nop_();	i = 4;	j = 205;	k = 187;	do	&#123;		do		&#123;			while (--k);		&#125; while (--j);	&#125; while...</div></div></div></a><a class="pagination-related" href="/2024/12/07/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5%E4%B8%8A%E5%AE%89%E8%A3%85stlink%E9%A9%B1%E5%8A%A8/" title="小米平板5上安装stlink驱动"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-07</div><div class="info-item-2">小米平板5上安装stlink驱动</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lca</div><div class="author-info-description">向着不完美的明天</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/luckylca"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:lca261224@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2777581179&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">长沙理工大学电气工程及其自动化专业在读，计算机小白一枚，记录生活，分享技术</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">32单片机系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-GPIO"><span class="toc-number">1.1.</span> <span class="toc-text">1.GPIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E7%81%AF-%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">点灯+蜂鸣器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E7%81%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">点灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">蜂鸣器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E8%BE%93%E5%85%A5"><span class="toc-number">1.3.</span> <span class="toc-text">GPIO输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E6%8E%A7%E5%88%B6%E7%82%B9%E7%81%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">按钮控制点灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">光敏传感器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OLED"><span class="toc-number">1.4.</span> <span class="toc-text">OLED</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82"><span class="toc-number">1.4.1.</span> <span class="toc-text">底层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%B0%84%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">对射红外传感器计次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E8%AE%A1%E6%AC%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">旋转编码计次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWM"><span class="toc-number">1.7.</span> <span class="toc-text">PWM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.8.</span> <span class="toc-text">ADC数模转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA"><span class="toc-number">1.9.</span> <span class="toc-text">DMA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E4%B8%8EADC%E7%9B%B8%E7%BB%93%E5%90%88"><span class="toc-number">1.10.</span> <span class="toc-text">DMA与ADC相结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">1.11.</span> <span class="toc-text">通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USART"><span class="toc-number">1.11.1.</span> <span class="toc-text">USART</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">发送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">1.11.2.</span> <span class="toc-text">USART发送接收数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIC%E9%80%9A%E4%BF%A1"><span class="toc-number">1.11.3.</span> <span class="toc-text">IIC通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FIIC"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">软件模拟IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IIC%E5%8A%A0MPU6050"><span class="toc-number">1.11.3.1.1.</span> <span class="toc-text">IIC加MPU6050</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%A8%A1%E6%8B%9FIIC"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">硬件模拟IIC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi%E9%80%9A%E4%BF%A1"><span class="toc-number">1.11.4.</span> <span class="toc-text">spi通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9Fspi"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">软件模拟spi</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%A8%A1%E6%8B%9Fspi"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">硬件模拟spi</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAN%E9%80%9A%E4%BF%A1"><span class="toc-number">1.11.5.</span> <span class="toc-text">CAN通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%B0%83%E7%94%A8CAN%E9%80%9A%E4%BF%A1"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">硬件调用CAN通信</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/29/%E9%95%BF%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%A0%B4%E8%A7%A3/" title="长理校园网多设备破解">长理校园网多设备破解</a><time datetime="2025-08-29T10:14:07.000Z" title="发表于 2025-08-29 18:14:07">2025-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/" title="数据结构技巧记录">数据结构技巧记录</a><time datetime="2025-08-17T16:29:16.000Z" title="发表于 2025-08-18 00:29:16">2025-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/" title="一加13从购买到毕业">一加13从购买到毕业</a><time datetime="2025-07-21T14:08:23.000Z" title="发表于 2025-07-21 22:08:23">2025-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/17/FreeRTOS%E5%AD%A6%E4%B9%A0/" title="FreeRTOS学习">FreeRTOS学习</a><time datetime="2025-06-17T03:14:51.000Z" title="发表于 2025-06-17 11:14:51">2025-06-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/01/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%AD%A6%E4%B9%A0app/" title="科目一学习app">科目一学习app</a><time datetime="2025-03-01T14:38:06.000Z" title="发表于 2025-03-01 22:38:06">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lca</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'g32U1MLRYi6iTVIZNW60EEJi-MdYXbMMI',
      appKey: '0sTUOgceVdlUrittyEAzqprS',
      avatar: 'monsterid',
      serverURLs: 'https://g32u1mlr.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Continuous Learning" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>