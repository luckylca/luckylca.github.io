<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>teat_life</title>
    <url>/2024/11/02/teat-life/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2024/11/02/test/</url>
    <content><![CDATA[<p>Markdown 是一种轻量级的标记语言，用于格式化纯文本。它允许您以简单的方式添加格式，而不需要复杂的 HTML 标签。以下是一些常用的 Markdown 语法：</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h4 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个段落。</span><br><span class="line"></span><br><span class="line">这是另一个段落。</span><br></pre></td></tr></table></figure>

<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">__粗体__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体_</span>__</span></span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li><p><strong>无序列表</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表项1</span><br><span class="line"><span class="bullet">-</span> 列表项2</span><br><span class="line"><span class="bullet">-</span> 列表项3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有序列表</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表项1</span><br><span class="line"><span class="bullet">2.</span> 列表项2</span><br><span class="line"><span class="bullet">3.</span> 列表项3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>嵌套列表</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表项1</span><br><span class="line"><span class="bullet">   -</span> 子列表项1</span><br><span class="line"><span class="bullet">   -</span> 子列表项2</span><br><span class="line"><span class="bullet">2.</span> 列表项2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接文本</span>](<span class="link">URL</span>)</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">替代文本</span>](<span class="link">图片URL</span>)</span><br></pre></td></tr></table></figure>

<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul>
<li><p><strong>内联代码</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`这是内联代码`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多行代码块</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```语言</span></span><br><span class="line"><span class="code">这是多行代码块</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 引用</span><br><span class="line">```markdown</span><br><span class="line">&gt; 这是一个引用块。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 列1 | 列2 | 列3 |</span><br><span class="line">| --- | --- | --- |</span><br><span class="line">| 内容1 | 内容2 | 内容3 |</span><br><span class="line">| 内容4 | 内容5 | 内容6 |</span><br></pre></td></tr></table></figure>

<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>

<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成的任务</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成的任务</span><br></pre></td></tr></table></figure>

<h4 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:smile:</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 我的第一篇 Markdown 文章</span></span><br><span class="line"></span><br><span class="line">这是一个段落。接下来是一些 <span class="strong">**粗体**</span> 和 <span class="emphasis">*斜体*</span> 的文字。</span><br><span class="line"></span><br><span class="line"><span class="section">## 子标题</span></span><br><span class="line"></span><br><span class="line">这是一个无序列表：</span><br><span class="line"><span class="bullet">-</span> 列表项1</span><br><span class="line"><span class="bullet">-</span> 列表项2</span><br><span class="line"><span class="bullet">-</span> 列表项3</span><br><span class="line"></span><br><span class="line">这是一个有序列表：</span><br><span class="line"><span class="bullet">1.</span> 列表项1</span><br><span class="line"><span class="bullet">2.</span> 列表项2</span><br><span class="line"><span class="bullet">3.</span> 列表项3</span><br><span class="line"></span><br><span class="line">这是一个链接：[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)</span><br><span class="line"></span><br><span class="line">这是一个图片：</span><br><span class="line">![<span class="string">Markdown Logo</span>](<span class="link">https://markdown-guide-images.vercel.app/logo-markdown.png</span>)</span><br><span class="line"></span><br><span class="line">这是一个代码块：</span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">def hello_world():</span></span><br><span class="line"><span class="code">    print(&quot;Hello, world!&quot;)</span></span><br></pre></td></tr></table></figure>

<p>这是一个引用：</p>
<blockquote>
<p>这是一个引用块。</p>
</blockquote>
<h2 id="这是一个水平线："><a href="#这是一个水平线：" class="headerlink" title="这是一个水平线："></a>这是一个水平线：</h2><p>这是一个表格：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>年龄</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>25</td>
<td>北京</td>
</tr>
<tr>
<td>李四</td>
<td>30</td>
<td>上海</td>
</tr>
</tbody></table>
<p>这是一个删除线：<br><del>错误的信息</del></p>
<p>这是一个任务列表：</p>
<ul>
<li><input checked disabled type="checkbox"> 已完成的任务</li>
<li><input disabled type="checkbox"> 未完成的任务</li>
</ul>
<p>这是一个表情符号：<br>:smile:</p>
<pre><code>
希望这些示例和语法能帮助您更好地使用 Markdown。如果您有任何具体问题或需要进一步的帮助，请随时提问！
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>11月札记</title>
    <url>/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h3><p>图书协会活动——图书馆看番</p>
<p>也是喜欢上了老八。</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/6778B314F59B2F02621AC44DD791A6E0.jpg" alt="6778B314F59B2F02621AC44DD791A6E0"></p>
<p>顺便记录一下图书馆地图</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/92407026223B2A53F8948AED0117C7E0.jpg" alt="92407026223B2A53F8948AED0117C7E0"></p>
<h3 id="11-4"><a href="#11-4" class="headerlink" title="11.4"></a>11.4</h3><p>西门外的卤肉店</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/15FF5EAD53B8A222749F1B697FAE7BD0.jpg" alt="15FF5EAD53B8A222749F1B697FAE7BD0"></p>
<p>这一碗加上饭才13，也是爽爽的吃撑了。</p>
<h2 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h2><p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/b38e78483b7002df9dd2dec1a6aeaa0b.jpeg" alt="b38e78483b7002df9dd2dec1a6aeaa0b"></p>
<p>再补张老八的图。</p>
<h2 id="11-30"><a href="#11-30" class="headerlink" title="11.30"></a>11.30</h2><p>和高中同学长沙寿司店爽吃，不得不说，日料是真的贵。</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/CRnall_20241130_132443938.jpg" alt="CRnall_20241130_132443938"></p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/CRnall_20241130_132603540.jpg" alt="CRnall_20241130_132603540"></p>
<p>鹅肝，好好吃，就是有点腥，挺嫩的。</p>
<p>然后还去了静安寺。</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/CRnall_20241130_145853861.jpg" alt="CRnall_20241130_145853861"></p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/CRnall_20241130_150250149.jpg" alt="CRnall_20241130_150250149"></p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/CRnall_20241130_150529452.jpg" alt="CRnall_20241130_150529452"></p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/CRnall_20241130_152047753.jpg" alt="CRnall_20241130_152047753"></p>
<p>随便拍了几张，大部分是谷歌相机80合1版本的直出，滤镜好像选了哈希自然，具体忘记了。</p>
<p>还有一部分是用的varlens，这个也挺好用的，滤镜蛮多的，算法也可以，就是我的手机硬件太差了。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>札记</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机实践系列合集</title>
    <url>/2024/11/12/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="此板块用来记录一些成熟的单片机程序"><a href="#此板块用来记录一些成熟的单片机程序" class="headerlink" title="此板块用来记录一些成熟的单片机程序"></a>此板块用来记录一些成熟的单片机程序</h1><h2 id="矩阵键盘密码锁"><a href="#矩阵键盘密码锁" class="headerlink" title="矩阵键盘密码锁"></a>矩阵键盘密码锁</h2><p>通过矩阵键盘输入数字，再调用lcd1602提供显示功能，来实现简单的验证密码的功能。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;lcd1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Martrixkey.h&quot;           //引入一系列的库</span></span><br><span class="line">unsigned int password,count;		//定义了密码变量跟计数变量</span><br><span class="line">unsigned char KeyNum;			//定义键码</span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	LCD_Init();</span></span><br><span class="line"><span class="code">	LCD_ShowString(1,1,&quot;Password:&quot;);	//初始化界面</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		KeyNum=MartrixKey();		//读取键位</span></span><br><span class="line"><span class="code">		if(KeyNum)</span></span><br><span class="line"><span class="code">		&#123;	if(KeyNum&lt;=10)		//计数代码</span></span><br><span class="line"><span class="code">				&#123;	</span></span><br><span class="line"><span class="code">					if(count&lt;4)</span></span><br><span class="line"><span class="code">					&#123;</span></span><br><span class="line"><span class="code">					password*=10;</span></span><br><span class="line"><span class="code">					password+=KeyNum%10;		//通过将原先的变量*10再加上现在的变量</span></span><br><span class="line"><span class="code">					count++;		//计数用，计数达到了4再输入就不会有任何结果了</span></span><br><span class="line"><span class="code">					&#125;</span></span><br><span class="line"><span class="code">					LCD_ShowNum(2,1,password,4);		//实时更新显示</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">			if(KeyNum==11)		//制作完成功能</span></span><br><span class="line"><span class="code">			&#123;</span></span><br><span class="line"><span class="code">				if(password==1145)		//密码值</span></span><br><span class="line"><span class="code">				&#123;</span></span><br><span class="line"><span class="code">					LCD_ShowString(1,14,&quot;OK &quot;);</span></span><br><span class="line"><span class="code">					password = 0;		//清零变量值</span></span><br><span class="line"><span class="code">					count=0;</span></span><br><span class="line"><span class="code">					LCD_ShowNum(2,1,password,4);</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">				else</span></span><br><span class="line"><span class="code">				&#123;</span></span><br><span class="line"><span class="code">					LCD_ShowString(1,14,&quot;ERR&quot;);</span></span><br><span class="line"><span class="code">					password = 0;</span></span><br><span class="line"><span class="code">					count=0;</span></span><br><span class="line"><span class="code">					LCD_ShowNum(2,1,password,4);</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">			</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">			if(KeyNum==12)		//清空按键</span></span><br><span class="line"><span class="code">			&#123;password=0;count=0;LCD_ShowNum(2,1,password,4);&#125;</span></span><br><span class="line"><span class="code">			//if(KeyNum==12)</span></span><br><span class="line"><span class="code">			//&#123;password=(password-password%10)/10;count--;LCD_ShowNum(2,1,password,4);&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>还有另一个版本，我做了些微调，以注释的形式添加到代码中了，作用的区别是一个直接赋值清空输入栏，第二种是减去后一位数字。</p>
<h2 id="电子时钟-计时器"><a href="#电子时钟-计时器" class="headerlink" title="电子时钟&#x2F;计时器"></a>电子时钟&#x2F;计时器</h2><p>通过定时器实现计时器或者电子时钟。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;LCD1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Timer0.h&quot;</span></span><br><span class="line">unsigned char Sec,min,hour;</span><br><span class="line">void main()</span><br><span class="line">&#123;			LCD<span class="emphasis">_Init();</span></span><br><span class="line"><span class="emphasis">	Timer0_</span>Init();</span><br><span class="line"><span class="code">	LCD_ShowString(1,1,&quot;Clock:&quot;);</span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">		 &#123;</span></span><br><span class="line"><span class="code">			 LCD_ShowNum(2,1,hour,2);</span></span><br><span class="line"><span class="code">			 LCD_ShowChar(2,3,&#x27;:&#x27;);</span></span><br><span class="line"><span class="code">			 LCD_ShowNum(2,4,min,2);</span></span><br><span class="line"><span class="code">			 LCD_ShowChar(2,6,&#x27;:&#x27;);</span></span><br><span class="line"><span class="code">			 LCD_ShowNum(2,7,Sec,2);	 </span></span><br><span class="line"><span class="code">		 &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void Timer0_Routine() interrupt 1				</span></span><br><span class="line"><span class="code">&#123;	static signed int T0Count;</span></span><br><span class="line"><span class="code">	TL0 = 0x66;		</span></span><br><span class="line"><span class="code">	TH0 = 0xFC;	</span></span><br><span class="line"><span class="code">	T0Count++;</span></span><br><span class="line"><span class="code">	if(T0Count&gt;=1000)</span></span><br><span class="line"><span class="code">	&#123;	T0Count=0;</span></span><br><span class="line"><span class="code">		Sec++;</span></span><br><span class="line"><span class="code">		if(Sec&gt;=60)</span></span><br><span class="line"><span class="code">		&#123;Sec=0;</span></span><br><span class="line"><span class="code">			min++;</span></span><br><span class="line"><span class="code">			if(min&gt;=60)</span></span><br><span class="line"><span class="code">			&#123;hour++;</span></span><br><span class="line"><span class="code">				if(hour&gt;=24)</span></span><br><span class="line"><span class="code">					hour=0;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>程序运行后，会从00：00：00开始计时，如果想当作时钟，也只用调整适当的Sec，min，hour初始命令即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机系列</title>
    <url>/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="51单片机系列"><a href="#51单片机系列" class="headerlink" title="51单片机系列"></a>51单片机系列</h1><p>此文章记录我学单片机进程，以及所写的代码集合，当作笔记和备份吧，以后可以温习用。</p>
<p>目前正在学的是51单片机，普中A2版本。</p>
<p>先上张原理图</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/%E6%99%AE%E4%B8%AD-2&%E6%99%AE%E4%B8%AD-3&%E6%99%AE%E4%B8%AD-4%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="开发板原理图"></p>
<p>再来张十六进制换算表</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/CRnall_20241103_004139503.jpg" alt="十六进制"></p>
<h2 id="LED模块"><a href="#LED模块" class="headerlink" title="LED模块"></a>LED模块</h2><h3 id="最简单的点灯代码"><a href="#最简单的点灯代码" class="headerlink" title="最简单的点灯代码"></a>最简单的点灯代码</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	P2 = 0xFE;</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>



<h3 id="控制点灯时间代码"><a href="#控制点灯时间代码" class="headerlink" title="控制点灯时间代码"></a>控制点灯时间代码</h3><p>通过软件内置的时间延迟计算生成函数，来控制时间。</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/CRnall_20241103_233001031.jpg" alt="CRnall_20241103_233001031"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">INTRINS.H</span>&gt;</span></span></span></span><br><span class="line">void Delay500ms()		//@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	unsigned char i, j, k;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	_nop_();</span></span><br><span class="line"><span class="code">	i = 4;</span></span><br><span class="line"><span class="code">	j = 205;</span></span><br><span class="line"><span class="code">	k = 187;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		do</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			while (--k);</span></span><br><span class="line"><span class="code">		&#125; while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">void main()</span><br><span class="line">&#123; </span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">	P2=0xFE;</span></span><br><span class="line"><span class="code">	Delay500ms();	</span></span><br><span class="line"><span class="code">	P2=0xFF;</span></span><br><span class="line"><span class="code">	Delay500ms();</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="流水灯代码"><a href="#流水灯代码" class="headerlink" title="流水灯代码"></a>流水灯代码</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">void Delay1ms(unsigned int xms)		//@12MHz</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	unsigned char i, j;</span></span><br><span class="line"><span class="code">	while(xms)&#123;</span></span><br><span class="line"><span class="code">		i = 2;</span></span><br><span class="line"><span class="code">		j = 239;</span></span><br><span class="line"><span class="code">		do</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			while (--j);</span></span><br><span class="line"><span class="code">		&#125; while (--i);</span></span><br><span class="line"><span class="code">		xms--;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		P2=0xFE;</span></span><br><span class="line"><span class="code">		Delay1ms(120);</span></span><br><span class="line"><span class="code">		P2=0xFD;</span></span><br><span class="line"><span class="code">		Delay1ms(500);</span></span><br><span class="line"><span class="code">		P2=0xFB;</span></span><br><span class="line"><span class="code">		Delay1ms(100);</span></span><br><span class="line"><span class="code">		P2=0xF7;</span></span><br><span class="line"><span class="code">		Delay1ms(200);</span></span><br><span class="line"><span class="code">		P2=0xEF;</span></span><br><span class="line"><span class="code">		Delay1ms(500);</span></span><br><span class="line"><span class="code">		P2=0xDF;</span></span><br><span class="line"><span class="code">		Delay1ms(400);</span></span><br><span class="line"><span class="code">		P2=0xBF;</span></span><br><span class="line"><span class="code">		Delay1ms(300);</span></span><br><span class="line"><span class="code">		P2=0x7F;</span></span><br><span class="line"><span class="code">		Delay1ms(100);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>通过调整函数变量，可以自由决定每一个灯亮起的时间跟间隔。</p>
<h3 id="按钮控制点灯v1"><a href="#按钮控制点灯v1" class="headerlink" title="按钮控制点灯v1"></a>按钮控制点灯v1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">void main()</span><br><span class="line">&#123;	while(1)</span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		if(P3_1==0)</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			P2_0=0;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">		else</span></span><br><span class="line"><span class="code">			P2_0=1;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>可以通过按钮的判断来控制小灯的亮灭了，但是这些代码只能需要按钮一直按下才可以把灯点亮，如果松开按钮灯就灭了，而且没有消抖。</p>
<h3 id="按钮控制点灯v2"><a href="#按钮控制点灯v2" class="headerlink" title="按钮控制点灯v2"></a>按钮控制点灯v2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">void Delay1ms(unsigned int xms)		//@12MHz</span><br><span class="line">&#123;	unsigned char i, j;</span><br><span class="line">while(xms&gt;0)&#123;</span><br><span class="line"><span class="code">	i = 2;</span></span><br><span class="line"><span class="code">	j = 239;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);</span></span><br><span class="line"><span class="code">	xms--;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;P2_0=0;</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		if(P3_1==0)</span></span><br><span class="line"><span class="code">		&#123;	Delay1ms(20);</span></span><br><span class="line"><span class="code">			while(P3_1==0);</span></span><br><span class="line"><span class="code">			Delay1ms(20);</span></span><br><span class="line"><span class="code">			P2_0=~P2_0;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>



<p>这个就相对完善了很多了，已经可以实现按钮按一次就会一直亮，再按就灭的功能，而且也加入了延时来消除抖动。也引入了位运算，可以通过取反来更加便捷地控制小灯亮灭。</p>
<h3 id="按钮控制点灯v3"><a href="#按钮控制点灯v3" class="headerlink" title="按钮控制点灯v3"></a>按钮控制点灯v3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">char LEDNum=0;</span><br><span class="line">void delay(int xms)		//@12MHz</span><br><span class="line">&#123;while(xms)</span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	unsigned char i, j;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	i = 2;</span></span><br><span class="line"><span class="code">	j = 239;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);</span></span><br><span class="line"><span class="code">	xms--;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;	 P2=~0x01;</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;	</span></span><br><span class="line"><span class="code">		if(P3_1==0)     //实现左移</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			delay(30);</span></span><br><span class="line"><span class="code">			while(P3_1==0)</span></span><br><span class="line"><span class="code">			delay(30);</span></span><br><span class="line"><span class="code">			LEDNum++;</span></span><br><span class="line"><span class="code">			if(LEDNum==8)</span></span><br><span class="line"><span class="code">				LEDNum=0;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">			P2 =~(0x01&lt;&lt;LEDNum);</span></span><br><span class="line"><span class="code">				if(P3_0==0)  //实现右移</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			delay(30);</span></span><br><span class="line"><span class="code">			while(P3_0==0)</span></span><br><span class="line"><span class="code">			delay(30);	</span></span><br><span class="line"><span class="code">			if(LEDNum==0)</span></span><br><span class="line"><span class="code">				LEDNum=7;		</span></span><br><span class="line"><span class="code">			else</span></span><br><span class="line"><span class="code">				LEDNum--;</span></span><br><span class="line"><span class="code">			P2 =~(0x01&lt;&lt;LEDNum);		</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>通过if语句和一个中间变量再加上移位运算和取反运算，最终实现了用两个按钮来控制小灯的亮起的左移和右移，并且对小灯在边缘亮起的情况做了处理，让其可以正常运行。</p>
<h2 id="静态数码管显示"><a href="#静态数码管显示" class="headerlink" title="静态数码管显示"></a>静态数码管显示</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">unsigned char nixietable[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00&#125;;</span><br><span class="line">void nixie(unsigned char location,number)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	switch(location)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		case 1:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 2:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 3:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 4:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 5:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 6:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 7:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 8:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=0;break;	</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">P0=nixietable[number];</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;	nixie(2,3);</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>定义了一个nixie的函数，用来更为方便的控制静态数码管，数码管的控制主要有两个来决定，一个是位，一个是数，在51单片机中，代码中的switch判断所控制的就是数码管的位置，采用的是38译码器，通过三个数的0和1来表示8个位置的数码管，大限度的减短控制所需要的接口，非常的巧妙，而代码中的nixietable数组则是控制显示的数字，通过十六进制的数字来控制所显示的东西，一切都刚刚好，具体可以去看原理图，如果使用的话，调用现成的库就足够了。</p>
<p>但是，这套控制系统虽然简单，只用了很少的接口，但是也有局限性，就是一次只能表示一个位置的一个数字，所以就有了动态数码管。</p>
<h2 id="动态数码管"><a href="#动态数码管" class="headerlink" title="动态数码管"></a>动态数码管</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">unsigned char nixietable[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00&#125;;</span><br><span class="line">void delay(int xms)		//@12MHz</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	unsigned char i, j;</span></span><br><span class="line"><span class="code">while(xms)&#123;</span></span><br><span class="line"><span class="code">	i = 2;</span></span><br><span class="line"><span class="code">	j = 239;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);xms--;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void nixie(unsigned char location,number)</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">	switch(location)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		case 1:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 2:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 3:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 4:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 5:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 6:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 7:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 8:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=0;break;	</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">P0=nixietable[number];</span></span><br><span class="line"><span class="code">delay(1);</span></span><br><span class="line"><span class="code">	P0=0x00;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;	</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	nixie(1,1);delay(5);</span></span><br><span class="line"><span class="code">	nixie(2,2);delay(5);</span></span><br><span class="line"><span class="code">	nixie(3,3);delay(5);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这个就已经比较完善了，通过delay延时，利用人眼的延时，只要变化的够快，人眼就感知不出来（doge）。</p>
<p>同时呢，也加入了消隐，可以避免数码管显示出错，当然，也可以让延时改为1毫秒，也可以避免显示出错。</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/8C07D227036A5E8622746F2B68EEAFC0.jpg" alt="666显示"></p>
<h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p>这是一种方法，我们可以将一些函数打包成一个.c文件和一个.h文件，只要做好声明并调用，就可以非常方便的使用这些函数了，并且也容易分享和修改。</p>
<p>下面是一个.h文件的示例</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#ifndef <span class="strong">__DELAY<span class="emphasis">_H_</span>_</span></span></span><br><span class="line"><span class="strong"><span class="section">#define __</span>DELAY<span class="emphasis">_H_</span>_</span></span><br><span class="line">void delay(int xms);</span><br><span class="line"><span class="section">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>.c文件就是类似于自定义函数的写法，放在同一目录下就可以正常使用了。</p>
<h2 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h2><p>为了简化io口，矩阵键盘也应用了类似于数码管的模式，仅使用了8个io口，便可以控制了16个矩阵按键，相应的，获取矩阵按键的状态，也是需要不断扫描，以时间赢得空间。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;lcd1602.h&quot;</span></span><br><span class="line">/**</span><br><span class="line"><span class="bullet">  *</span> @brief  矩阵键盘读取按健键码</span><br><span class="line"><span class="bullet">  *</span> @param  无</span><br><span class="line"><span class="bullet">  *</span> @retval 按下按键的键码值</span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">unsigned char Martrixkey()</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	unsigned char KeyNumber = 0;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_3=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=1;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=5;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=9;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=13;&#125;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_2=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=2;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=6;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=10;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=14;&#125;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_1=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=3;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=7;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=11;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=15;&#125;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_0=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=4;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=8;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=12;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=16;&#125;</span></span><br><span class="line"><span class="emphasis">	return KeyNumber;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这是矩阵键盘模块的内部代码，以按列扫描的模式，不断读取每个按键的状态，并返回相对应的结果。</p>
<p>下面是一个简单的矩阵键盘使用案例。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;lcd1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Martrixkey.h&quot;</span></span><br><span class="line">unsigned char KeyNum;</span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	LCD_Init();</span></span><br><span class="line"><span class="code">	LCD_ShowString(1,2,&quot;Hello world&quot;);</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		KeyNum=MartrixKey();</span></span><br><span class="line"><span class="code">		if(KeyNum)</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			LCD_ShowNum(2,1,KeyNum,2);		</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这些代码通过调用矩阵键盘的模块可以实现读取键盘的数值，并让其实时打印在LCD屏幕上。</p>
<h2 id="定时器系列"><a href="#定时器系列" class="headerlink" title="定时器系列"></a>定时器系列</h2><p>delay函数之所以可以延时，是因为它通过让cpu执行一系列空的事情，来拖延出时间，所以当我们在运行delay函数时，cpu是占满的，我们这个时候再想运行其他函数，cpu是不会响应的，有弊端在，所以，引入了一个重要的模块——<strong>定时器</strong>。</p>
<p>定时器，是芯片内部的资源，通过晶振来推动，51单片机定时器0内部有两个寄存器TH0和TL0,都是一字节的，理解位定时器0高位寄存器（TH0），定时器0低位寄存器（TL0）, 我们知道2字节最大能存0到65535一共65536个数字。每过一个指令周期（1us），寄存器的值+1，当加到溢出后发出一个溢出中断，我们程序可以捕获到这个中断，并执行中断函数内容，就可以知道此时经历了（65535+1）us。如果我们要定时1ms，设置寄存器的初值为64536，这样到溢出值65536就正好1ms。如果想要定时1s的话，设置一个计数器，让定时器循环1000次即可。</p>
<p>定时器由于是芯片内部的资源，所以不需要特别占用cpu，比delay好很多。</p>
<p>下面就是一个简单的由定时器驱动的程序。这是一个按键控制流水灯的程序，按下按键，流水灯就会换一个方向亮起，引入了第三方库INTRINS.h。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;Timer0.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Key.h&quot;</span></span><br><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">INTRINS.H</span>&gt;</span></span></span></span><br><span class="line">unsigned char KeyNum,LEDmode;</span><br><span class="line">void main()</span><br><span class="line">&#123;		P2=0xFE;</span><br><span class="line"><span class="code">		Timer0_Init(); </span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">	&#123;	</span></span><br><span class="line"><span class="code">		KeyNum=Key();</span></span><br><span class="line"><span class="code">		if(KeyNum)</span></span><br><span class="line"><span class="code">		&#123;	</span></span><br><span class="line"><span class="code">			if(KeyNum==1)</span></span><br><span class="line"><span class="code">			&#123;	</span></span><br><span class="line"><span class="code">				LEDmode++;</span></span><br><span class="line"><span class="code">				if(LEDmode&gt;=2)LEDmode=0;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void Timer0_Routine() interrupt 1		//中断程序内容</span></span><br><span class="line"><span class="code">&#123;	static signed int T0Count;</span></span><br><span class="line"><span class="code">	TL0 = 0x66;		</span></span><br><span class="line"><span class="code">	TH0 = 0xFC;	</span></span><br><span class="line"><span class="code">	T0Count++;</span></span><br><span class="line"><span class="code">	if(T0Count&gt;=1000)		//计次1000次以达到1s钟</span></span><br><span class="line"><span class="code">	&#123;	T0Count=0;</span></span><br><span class="line"><span class="code">		if(LEDmode==0)</span></span><br><span class="line"><span class="code">			P2=_crol_(P2,1);</span></span><br><span class="line"><span class="code">		if(LEDmode==1)</span></span><br><span class="line"><span class="code">			P2=_cror_(P2,1);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>像这种程序如果不用定时器而用delay是实现不了的，或者说效果很差，按键根本反应不了。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">void Timer0<span class="emphasis">_Init()</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	TMOD &amp;= 0xF0;		</span></span><br><span class="line"><span class="emphasis">	TMOD |= 0x01;		</span></span><br><span class="line"><span class="emphasis">	TL0 = 0x66;		</span></span><br><span class="line"><span class="emphasis">	TH0 = 0xFC;		</span></span><br><span class="line"><span class="emphasis">	TF0 = 0;		</span></span><br><span class="line"><span class="emphasis">	TR0 = 1;		</span></span><br><span class="line"><span class="emphasis">	ET0=1;</span></span><br><span class="line"><span class="emphasis">	EA=1;</span></span><br><span class="line"><span class="emphasis">	PT0=0;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这是定时器的内部寄存器配置。</p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>PWM是一种控制输出电功率的方法，就是控制高低电平的比例，从而控制电力的输出，常用的领域有呼吸灯的制作，还有电机的调速。</p>
<h3 id="呼吸灯"><a href="#呼吸灯" class="headerlink" title="呼吸灯"></a>呼吸灯</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">sbit LED=P2^0;</span><br><span class="line">void delay(unsigned int t)  //简易延时函数</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	while(t--);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;		signed char time,t;</span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">&#123;	</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	for(time=0;time&lt;100;time++)</span></span><br><span class="line"><span class="code">	&#123; </span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		for(t=0;t&lt;20;t++)		//灯泡亮暗的速度太快了，加入这个循环，降低其速度</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			LED=0;</span></span><br><span class="line"><span class="code">			delay(time);</span></span><br><span class="line"><span class="code">			LED=1;</span></span><br><span class="line"><span class="code">			delay(100-time);</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">		for(time=100;time&gt;0;time--)</span></span><br><span class="line"><span class="code">	&#123; </span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		for(t=0;t&lt;20;t++)</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			LED=0;</span></span><br><span class="line"><span class="code">			delay(time);</span></span><br><span class="line"><span class="code">			LED=1;</span></span><br><span class="line"><span class="code">			delay(100-time);</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个有用了delay的方法，有规律的控制小灯暗亮。</p>
<h3 id="电机调速"><a href="#电机调速" class="headerlink" title="电机调速"></a>电机调速</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Key.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;LCD1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Martrixkey.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;nixie.h&quot;</span></span><br><span class="line">unsigned char counter,compare;</span><br><span class="line">unsigned char keynum,speed;</span><br><span class="line">sbit Motor = P1^0;</span><br><span class="line">void main()</span><br><span class="line">&#123;		Timer0<span class="emphasis">_Init();</span></span><br><span class="line"><span class="emphasis">     while(1)</span></span><br><span class="line"><span class="emphasis">&#123;	</span></span><br><span class="line"><span class="emphasis">	keynum=Key();</span></span><br><span class="line"><span class="emphasis">	if(keynum==1)</span></span><br><span class="line"><span class="emphasis">	&#123;</span></span><br><span class="line"><span class="emphasis">		speed++;</span></span><br><span class="line"><span class="emphasis">		speed%=4;</span></span><br><span class="line"><span class="emphasis">		if(speed==0)compare=0;</span></span><br><span class="line"><span class="emphasis">		if(speed==1)compare=50;</span></span><br><span class="line"><span class="emphasis">		if(speed==2)compare=75;</span></span><br><span class="line"><span class="emphasis">		if(speed==3)compare=100;</span></span><br><span class="line"><span class="emphasis">	&#125;</span></span><br><span class="line"><span class="emphasis">	nixie(1,speed);</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">void Timer0_</span>Routine() interrupt 1				</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	TL0 = 0xA4;		</span></span><br><span class="line"><span class="code">	TH0 = 0xFF;	</span></span><br><span class="line"><span class="code">	counter++;</span></span><br><span class="line"><span class="code">	if(counter&gt;100)</span></span><br><span class="line"><span class="code">	&#123;counter=0;				//counter%=100;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	if(counter&lt;compare)</span></span><br><span class="line"><span class="code">		Motor=1;</span></span><br><span class="line"><span class="code">	else</span></span><br><span class="line"><span class="code">		Motor=0;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一共有三档调速度，通过比较counter和compare两个变量的大小，来控制电机的运转与否。</p>
<h2 id="8-8点阵屏"><a href="#8-8点阵屏" class="headerlink" title="8*8点阵屏"></a>8*8点阵屏</h2><p>8*8点阵屏是一个由64个小灯组成的小屏幕，类似于矩阵键盘，也是通过时间换io口，总共只需要控制11个io口，就可以在点阵屏上显示内容，，采用的是按列扫描的模式，而控制每一列的内容，则是通过3个io口进行处理，需要74HC595模块，就想填子弹一样，一个一个把数据填进寄存器，再统一发送到点阵屏上。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"></span><br><span class="line">sbit RCK=P3^5;		//RCLK</span><br><span class="line">sbit SCK=P3^6;		//SRCLK</span><br><span class="line">sbit SER=P3^4;		//SER</span><br><span class="line"></span><br><span class="line"><span class="section">#define MATRIX<span class="emphasis">_LED_</span>PORT    P0</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"><span class="bullet">  *</span> @brief  	控制每一列的输入</span><br><span class="line"><span class="bullet">  *</span> @param  </span><br><span class="line"><span class="bullet">  *</span> @retval </span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">void _74HC595_WriteByte(unsigned char Byte)</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	unsigned char  i;</span></span><br><span class="line"><span class="emphasis">	for(i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="emphasis">	&#123;</span></span><br><span class="line"><span class="emphasis">		SER=Byte&amp;(0x80&gt;&gt;i);</span></span><br><span class="line"><span class="emphasis">		SCK=1;</span></span><br><span class="line"><span class="emphasis">		 SCK=0;</span></span><br><span class="line"><span class="emphasis">	</span></span><br><span class="line"><span class="emphasis">	&#125;</span></span><br><span class="line"><span class="emphasis">	RCK=1;RCK=0;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">/*</span>*</span><br><span class="line"><span class="bullet">  *</span> @brief  点阵屏显示一列数据</span><br><span class="line"><span class="bullet">*</span> @param  column 要选择的列，范围0-7，date 要选择的列的数据，高位在上，1为亮</span><br><span class="line"><span class="bullet">  *</span> @retval </span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">void MatrixLED_ShowColumn(unsigned char column,date)</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	_74HC595_WriteByte(date);</span></span><br><span class="line"><span class="emphasis">	MATRIX_LED_PORT=~(0x80&gt;&gt;column);</span></span><br><span class="line"><span class="emphasis">	delay(1);</span></span><br><span class="line"><span class="emphasis">	MATRIX_LED_PORT=0xFF;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">void main()</span></span><br><span class="line"><span class="emphasis">&#123;		SCK=0;</span></span><br><span class="line"><span class="emphasis">		RCK=0;		///</span></span><br><span class="line"><span class="emphasis">		</span></span><br><span class="line"><span class="emphasis">     while(1)</span></span><br><span class="line"><span class="emphasis">&#123;	</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(0,0x3c);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(1,0x42);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(2,0xA9);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(3,0x85);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(4,0x85);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(5,0xA9);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(6,0x42);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(7,0x3c);</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是一个简单的在点阵屏显示笑脸的代码，没有进行模块化处理，想要模块化处理就定义一个初始化函数跟一个显示函数就可以了，当然，这个点阵屏也是实时扫描的，所以想进行同时进行其他任务比较困难，当然也可以带上定时器试试。</p>
<p>效果图如下</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/CRnall_20241123_002500248.jpg" alt="CRnall_20241123_002500248"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;MatrixLED.h&quot;</span></span><br><span class="line"></span><br><span class="line">unsigned char code Animation[]=</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;					//这个数组存放所有的列的信息</span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	unsigned char i,offset,count=0;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	void Martrix_LED_Init();</span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">&#123;	</span></span><br><span class="line"><span class="code">	for(i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	MatrixLED_ShowColumn(0,Animation[i+offset]);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	count++;</span></span><br><span class="line"><span class="code">	if(count&gt;10)		//调整速度用的</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		count=0;</span></span><br><span class="line"><span class="code">		offset++;		//如果是显示一帧一帧的动画，而不是流水的图案，则需要改成offset+=8;</span></span><br><span class="line"><span class="code">		offset%=24;		//这个要随时调</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些代码可以实现在8*8点阵屏上显示动画，将所有动画的每一行的内容，写进数组Animation中，然后再按照规律进行遍历，就可以显示动画了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向系列</title>
    <url>/2024/11/11/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h3 id="安卓逆向系列"><a href="#安卓逆向系列" class="headerlink" title="安卓逆向系列"></a>安卓逆向系列</h3><p>这系列文章记录一下简单的安卓逆向方面的思路和知识，以备查阅使用。</p>
<h3 id="安卓基本框架"><a href="#安卓基本框架" class="headerlink" title="安卓基本框架"></a>安卓基本框架</h3><p>apk相当于一个zip文件，里面打包了这个安卓程序所有的资源和代码，逆向也是对这个zip文件进行处理。</p>
<p>assets目录：存放静态资源，如视频，图片，音乐等等，一般可以用来替换图像。</p>
<p>lib目录：动态链接库</p>
<p>META-INF目录：保存应用签名信息，逆向安卓程序常常需要去除签名验证，否则程序会无法运行。</p>
<p>res目录：也是存放资源的文件，apk的图标就是在这里面调整。</p>
<p>AndroidManifest.xml文件：储存了安卓包的基本信息，比如应用名字，版本，包名，权限等等，一般处理共存或者去除更新会需要处理这个文件，也可以删除一些你不想要的权限，防止权限过度索取。</p>
<p>classes.dex文件：安卓主要的逻辑代码文件，大部分逆向破解都是在这里面修改判断逻辑，有一个或者很多文件。</p>
<p>resources.arsc文件：映射表，映射资源和id，当dex搜索不到关键词时可以来这里进行搜索，获取到资源id后然后再在dex里搜索。</p>
<h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>基本上字符串都在arsc里，直接选中arsc文件并且进入翻译模式就可以了，可以一个个手动翻译，也可以用插件翻译。</p>
<p>也可以在安装包里全局搜索（开启高级搜索），就可以直接搜索到相应的字符串。如果碰到了不知道语言的一段文字，可以使用开发者助手，授权root权限后，在对应应用中选择界面资源分析，就可以选中并且复制该段文字，再进行全局搜索。</p>
<p>替换图标，就用np管理器的通用编辑即可，可以一键修改图标，版本或者名字</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>逆向 安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>python人脸检测</title>
    <url>/2024/11/15/python%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="python人脸检测"><a href="#python人脸检测" class="headerlink" title="python人脸检测"></a>python人脸检测</h1><p>最近突然对图像识别有了点兴趣，便开始找一些识别的库，我这里采用的是python+opencv的方法，利用opencv内置的人脸检测库，可以比较方便快速地检测出人脸，学的很浅，也就图一乐。记录下来也只是为了以后便于回忆。</p>
<h2 id="将图片转化为灰度图片"><a href="#将图片转化为灰度图片" class="headerlink" title="将图片转化为灰度图片"></a>将图片转化为灰度图片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line">cv.imshow(&#x27;test&#x27;, img)</span><br><span class="line">gray<span class="emphasis">_img = cv.cvtColor(img, cv.COLOR_</span>BGR2GRAY)</span><br><span class="line">cv.imshow(&#x27;gray&#x27;, gray<span class="emphasis">_img)</span></span><br><span class="line"><span class="emphasis">cv.imwrite(&#x27;testlca_</span>gray.jpg&#x27;, gray<span class="emphasis">_img)</span></span><br><span class="line"><span class="emphasis">cv.waitKey(0)</span></span><br><span class="line"><span class="emphasis">cv.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>



<p>首先读取名叫testlca.jpg的图片，并且将它的命名为img，然后展示这个图片，再用opencv内置的函数，将这个图片转化为灰度图片，并且写入到testlca_gray.jpg文件，也展示这个图片。</p>
<p>一般处理图片，都需要先将其转化为灰度图片，然后再进行一系列的识别等步骤。</p>
<h2 id="调整图片大小"><a href="#调整图片大小" class="headerlink" title="调整图片大小"></a>调整图片大小</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line">cv.imshow(&#x27;test&#x27;, img)</span><br><span class="line">resize<span class="emphasis">_test = cv.resize(img, (200,200), fx=0.5, fy=0.5)</span></span><br><span class="line"><span class="emphasis">cv.imshow(&#x27;resize_</span>test&#x27;, resize<span class="emphasis">_test)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">while True:</span></span><br><span class="line"><span class="emphasis">    if ord(&#x27;q&#x27;) == cv.waitKey(0):</span></span><br><span class="line"><span class="emphasis">        break</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">cv.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>



<p>同样读取文件，这里将img图片进行了修改，将它转化为200*200像素的图片，并且也展示出来，还做了一个按键检测，当按下q的时候，图片才会关闭。</p>
<h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">x,y,w,h = 100,100,100,100</span><br><span class="line">cv.rectangle(img, (x,y), (x+w,y+h), (0,0,255), 2)</span><br><span class="line">cv.circle(img, (x+w//2,y+h//2), 50, (0,255,0), 2)</span><br><span class="line"></span><br><span class="line">cv.imshow(&#x27;img&#x27;, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line"><span class="code">    if ord(&#x27;q&#x27;) == cv.waitKey(0):</span></span><br><span class="line"><span class="code">        break</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>



<p>这里定义并赋值了4个变量，并且在图片上打印了对应位置的矩形和圆形。</p>
<h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">def face_detect_demo():</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    face_detector = cv.CascadeClassifier(&#x27;E:/python/opencv/sources/data/haarcascades/haarcascade_eye.xml&#x27;)</span><br><span class="line">    face = face_detector.detectMultiScale(gray,1.9,5)</span><br><span class="line">    for x, y, w, h in face:</span><br><span class="line">        cv.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 2)</span><br><span class="line">    cv.imshow(&#x27;result&#x27;, img)</span><br><span class="line"></span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line">face_detect_demo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    if ord(&#x27;q&#x27;) == cv.waitKey(0):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>



<p>先定义了一个检测函数，这里非常简陋，也没做参数处理了，原理就是调用官方的人脸识别库识别出图片中的人脸，并且用矩形框显示出来。</p>
<p>其中face_detector.detectMultiScale这个函数中的第二个变量叫缩小比例，是影响效果的重要变量，要选取适当的变量值才可以正确的识别出所有人脸。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次离谱的刷机经历</title>
    <url>/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在我爸换新手机后，我果断拿掉了我爸的旧手机，想来锻炼我的刷机技巧，我爸的手机是努比亚z17，已经非常老了，但在当时这台手机可是非常出名的，酷安评分非常高，刷机资源也比较多，我于是便开始了我的刷机操作。</p>
<h1 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h1><p>这款机型的刷机本来应该就是一个行云流水的通用刷机操作，努比亚z17有bl锁，只需要每次输一次解锁命令就可以解bl锁，非常容易，但是我却碰到了个非常棘手的情况。</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/147DDA3A399B7028E94DA70AEB855EA9.jpg" alt="故障1"></p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/0F5E47584C7EA15BE8769031F2B066AF.jpg" alt="故障2"></p>
<p>特别离谱是吧。就是这样子的，adb devices跟fastboot devices可以正常读取到设备，但就是传不了boot.img到机器上，bl锁也显示已经解了，各种不同的原因报错，我找了整整几个小时，换了无数根线，甚至还担心是不是接口2.0的问题，还换了台电脑测试，结果就只是报错的原因不一样。</p>
<p>我真的几乎放弃了，已经不打算刷机了，无聊地刷着酷安，也在徒劳的问大佬们问题，酷安一位酷u给我推荐了某贼的一篇文章，就是针对这台设备通过9008授权深刷的，本身这台机子进入9008模式不需要工程线，或者拆机短接等复杂的操作，直接在fb界面就可以进入9008了。</p>
<p>于是，我带着仅剩的一点希望，下载某贼的深刷包，开始下一次测试。</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/26F4F6D59768EDD41DDD40BD92811E61.jpg" alt="9008"></p>
<p>可是没想到又翻车了。</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/6C76DD8FB7980640E3EA4AED489F93C4.jpg" alt="9008故障"></p>
<p>后来我灵机一动，想到我在安装一个驱动提示要重启时，没有理这个重启提示，直接进行操作了，难怪报错了。</p>
<p>重启后再试了一次，非常成功，从安卓8升到了安卓9，fastboot也可以正常使用了，twrp，启动！</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/6B22BBA244B574F699C845781E012A7A.jpg" alt="trwp1"></p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/47304F0030363AB5DECB43089BD89B01.jpg" alt="twrp2"></p>
<p>非常丝滑的一顿操作，修补镜像，刷入magisk，成功获取root权限，也成功开始使用魔趣类原生，真没想到，魔趣系统虽然已经停止运营了，但我仍然再sourceforge平台上找到了他的包，甚至还是专门针对努比亚z17做的包，哎，这是上一个刷机时代的眼泪啊，酷安遗风了。</p>
<p>附张使用图</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/60105DFB27E857021D7BC119FC4285FC.jpg" alt="moqu"></p>
<p>接着刷入了gaps，美滋滋，这一段玩机之旅也告一段落了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这或许就是刷机搞机的魅力吧，你可能会碰到无数问题，任何一个细节的问题都是致命的，比如中文路径什么的，但是解决了却非常有成就感，其实我看的某贼的那篇文章，是为了解决努比亚z17获取永久bl权限的，只有那个版本的包可以一行代码永久去除bl锁，但是却误打误撞解决了我的问题。</p>
<p>这次经历也告诉我们，碰到这种离奇的报错，可能是系统问题，尝试用9008或者com1.0深刷换一个系统，说不定有机会解决，我碰到的这个问题，网上我目前还没找到类似的问题和解决方案。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>32单片机系列</title>
    <url>/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="32单片机系列"><a href="#32单片机系列" class="headerlink" title="32单片机系列"></a>32单片机系列</h1><p>51的学习暂时告一段落，也要继续学习stm32了。目前用的板子是江协的stm32f103c8的版本，先尝试着学习一下标准库的用法，虽然很难，但可以很好的理解计算机底层内容，尽力学吧，实在受不了就转向stmcubmax加hal库的方案。</p>
<h2 id="1-GPIO"><a href="#1-GPIO" class="headerlink" title="1.GPIO"></a>1.GPIO</h2><p>GPIO全拼叫General Purpose Input Output（通用输入输出）简称IO口，作用是用来控制连接在此GPIO口上的外设，通俗来说，就是单片机芯片通过控制IO口的电流输出，来起到控制外设的作用。</p>
<p>GPIO原理图</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-12-12174243.png" alt="屏幕截图2024-12-12174243"></p>
<p>一共有8种方式，但是一般常用输出方式就是推挽输出和开漏输出，而常用的输入方式是上拉输入和下拉输入，两者的区别就在于当没有外设给io口电平时，二者的默认电平不一样。</p>
<p>推挽输出同时支持高低电平驱动，方便快速切换电平，但是不支持线与（这个目前还没接触过），开漏输出就只支持低电平输入，电压取决于外部电压。</p>
<h2 id="点灯-蜂鸣器"><a href="#点灯-蜂鸣器" class="headerlink" title="点灯+蜂鸣器"></a>点灯+蜂鸣器</h2><h3 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h3><p>又是熟悉的点灯环节。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;stm32f10x.h&quot;                  // Device header</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);		<span class="comment">//初始化时钟</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;		<span class="comment">//定义gpio的一个结构体</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;		</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		<span class="comment">//分别设置结构体的三个参数</span></span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);		<span class="comment">//初始化GPIO</span></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);		<span class="comment">//可以写入对应IO口的值</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果图</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/A441DB3829A9723EC109E8F8ACA8D7E1.jpg" alt="A441DB3829A9723EC109E8F8ACA8D7E1"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个就引入了延时函数，可以实现小灯的频闪，但是这个32的delay函数跟51一样，还是通过执行无用的指令来拖延时间。</p>
<h3 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本质上是一样的，无非就是改一下初始化的GPIO口，和调整对应的赋值。</p>
<p>然后蜂鸣器有三个接口，用公母线连接到面包板上，分别是vcc，gnd和控制音频的引脚。也是跟小灯一样的赋值即可。</p>
<h2 id="GPIO输入"><a href="#GPIO输入" class="headerlink" title="GPIO输入"></a>GPIO输入</h2><h3 id="按钮控制点灯"><a href="#按钮控制点灯" class="headerlink" title="按钮控制点灯"></a>按钮控制点灯</h3><p>首先是按钮驱动的配置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> KeyNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>);</span><br><span class="line">		KeyNum=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11)==<span class="number">0</span>);</span><br><span class="line">		KeyNum=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> KeyNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>都是先是正常的初始化函数，即设置GPIO参数，然后再写读取按钮函数，通过返回8位的int数据，来表示按钮的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	LED_Init();</span><br><span class="line">	Key_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();</span><br><span class="line">		<span class="keyword">if</span>(KeyNum==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED1_Turn();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(KeyNum==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			LED2_Turn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是主函数，逻辑很简单，就是通过判断Key_GetNum返回的值来判断按键的状态，其中，LED_Turn函数的内容就是如果GPIO输出为1就置为0，为0就置为1，的一个简单的反转函数。</p>
<h3 id="光敏传感器"><a href="#光敏传感器" class="headerlink" title="光敏传感器"></a>光敏传感器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LightSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_SetBits(GPIOB,GPIO_Pin_13);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LightSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>都大同小异，光敏传感器驱动也是一样的初始化函数加一个读取函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;   // Device header</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;LED.h&quot;</span><br><span class="line">#include &quot;key.h&quot;</span><br><span class="line">#include &quot;Buzzer.h&quot;</span><br><span class="line">#include &quot;LightSensor.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	Buzzer_Init();</span><br><span class="line">	LightSensor_Init();</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(LightSensor_Get()==1)</span><br><span class="line">			Buzzer_ON();</span><br><span class="line">		else</span><br><span class="line">			Buzzer_OFF();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样就实现了当光不照射时，蜂鸣器一直响，当光照射时，蜂鸣器不响。</p>
<h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><p>这个跟51单片机类似，用的是江科协的库，直接调用对应的函数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	OLED_ShowChar(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">	OLED_ShowNum(<span class="number">2</span>,<span class="number">1</span>,<span class="number">12345</span>,<span class="number">5</span>);</span><br><span class="line">	OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">7</span>,<span class="number">-66</span>,<span class="number">3</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>,<span class="number">1</span>,<span class="number">0xAA55</span>,<span class="number">4</span>);		<span class="comment">//显示十六进制</span></span><br><span class="line">	OLED_ShowBinNum(<span class="number">4</span>,<span class="number">1</span>,<span class="number">0xAA55</span>,<span class="number">16</span>);		<span class="comment">//显示二进制</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>OLED所用的芯片SSD1306支持spi和iic通信，但是我的OLED只有两个iic通信接口，于是就是用iic通信了。</p>
<p>iic底层用的是软件模拟iic，不需要改动什么。</p>
<p>这款OLED是128*64的分辨率，所有的显示信息都储存在GDDRAM中，芯片会不断扫描这个GDDROM，将结果显示在OLED屏幕上，所以我们只需要对GDDRAM进行操作就可以了。</p>
<p>而这128*64又可以被分为 128*8byte，所以整个结构可以分为竖着的是128列，横着的是8页，一页就是一个字节，数据的存储就是一个字节的数据对用一列的一页，扫描也是从上到下，一页一页地扫描。</p>
<p>关键是拼凑SSD1306所需要的通信结构，</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-05-02_01-30-11.png" alt="PixPin_2025-05-02_01-30-11"></p>
<p>如上图所示，首先是起始信号，然后是从机地址跟读写位的设置，因为这个模块只写不读，所以这个字节直接设置为0x78就可以了，然后下一个数据是设置dc和连续性，其中dc置0就是命令模式，置1就是数据模式，co可以设置连续或者非连续发送，不过一般都是使用非连续发送。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OLED_WriteCommand</span><span class="params">(<span class="type">uint8_t</span> command)</span><span class="comment">//写入命令的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x78</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x00</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(command);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_WriteData</span><span class="params">(<span class="type">uint8_t</span> data)</span><span class="comment">//写入数据的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x78</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0x40</span>);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(data);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面是一些基础函数。</p>
<p>然后就可以基于基础函数构造一些高级的函数了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myoled_Init</span><span class="params">()</span><span class="comment">//初始化函数，具体操作细节可以查看手册</span></span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_Init();</span><br><span class="line">	Delay_ms(<span class="number">100</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xAE</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xD5</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x80</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA8</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x3F</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xD3</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x00</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x40</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA1</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xC8</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xDA</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x12</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x81</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xCF</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xD9</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xF1</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xDB</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x30</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA4</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xA6</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x8D</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x14</span>);</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xAF</span>);</span><br><span class="line">	Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SetCursor</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page)</span><span class="comment">//设置写入的位置，相当于设置鼠标光标位置</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x00</span> | (x &amp; <span class="number">0x0F</span>));</span><br><span class="line">	OLED_WriteCommand(<span class="number">0x10</span> | ((x &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>));</span><br><span class="line">	OLED_WriteCommand(<span class="number">0xB0</span> | page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Clear</span><span class="params">()</span><span class="comment">//清屏函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> j = <span class="number">0</span>;j&lt;<span class="number">8</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_SetCursor(<span class="number">0</span>,j);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(<span class="number">0x00</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChar</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">char</span> ch,<span class="type">uint8_t</span> fontsize)</span><span class="comment">//展示单个字符</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(fontsize==<span class="number">6</span>)&#123;</span><br><span class="line">		OLED_SetCursor(x,page);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(ascii_6x8[ch - <span class="string">&#x27; &#x27;</span>][i]);<span class="comment">//ascii_6x8是一个二维数组，存放取模出来的ascall码</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(fontsize==<span class="number">8</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_SetCursor(x,page);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(OLED_F8_16[ch - <span class="string">&#x27; &#x27;</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		OLED_SetCursor(x,page+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(OLED_F8_16[ch - <span class="string">&#x27; &#x27;</span>][i+<span class="number">8</span>]);</span><br><span class="line">		&#125;		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowString</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">char</span> *ch,<span class="type">uint8_t</span> fontsize)</span><span class="comment">//遍历展示字符串</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;ch[i] != <span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowChar(x+i*fontsize,page,ch[i],fontsize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowImg</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">uint8_t</span> width,<span class="type">uint8_t</span> height,<span class="type">uint8_t</span> *img)</span><span class="comment">//显示图片</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> j=<span class="number">0</span>;j&lt;height;j++)<span class="comment">//这里的height准确来说应该是page</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_SetCursor(x,page+j);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;width;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_WriteData(img[width*j+i]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowChinese</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> page,<span class="type">char</span> *Chinese)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> signalchinese[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//存储单个中文</span></span><br><span class="line">	<span class="comment">//char signalchinese[4] = &quot;中&quot;; // 实际存储为 &#123;&#x27;\xE4&#x27;, &#x27;\xB8&#x27;, &#x27;\xAD&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line">	<span class="type">uint8_t</span> pchinese = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint8_t</span> pindex ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;Chinese[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		signalchinese[pchinese] = Chinese[i];</span><br><span class="line">		pchinese++;</span><br><span class="line">		<span class="keyword">if</span>(pchinese&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">			pchinese=<span class="number">0</span>;<span class="comment">//到了3就可以拿出一个单个的中文出来了。</span></span><br><span class="line">			<span class="keyword">for</span>(pindex=<span class="number">0</span>;<span class="built_in">strcmp</span>(OLED_CF_16_16[pindex].Index,<span class="string">&quot;&quot;</span>)!=<span class="number">0</span>;pindex++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strcmp</span>(OLED_CF_16_16[pindex].Index,signalchinese) == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果遍历字模库中发现有相同的中文，就立马退出循环，显示中文</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			OLED_ShowImg(x+((i+<span class="number">1</span>)/<span class="number">3</span><span class="number">-1</span>)*<span class="number">16</span>),page,<span class="number">16</span>,<span class="number">2</span>,OLED_CF_16_16[pindex].Data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是关于中文字模的结构体定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> Index[<span class="number">4</span>];</span><br><span class="line">	<span class="type">uint8_t</span> Data[<span class="number">32</span>];</span><br><span class="line">&#125; ChineseCell_t;</span><br><span class="line"><span class="type">const</span> ChineseCell_t OLED_CF_16_16[]=</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;你&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0xF8</span>,<span class="number">0x07</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x0F</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="comment">/*,0*/</span></span><br><span class="line"><span class="string">&quot;好&quot;</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x1F</span>,<span class="number">0x10</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0xE2</span>,<span class="number">0x92</span>,<span class="number">0x8A</span>,<span class="number">0x86</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x40</span>,<span class="number">0x22</span>,<span class="number">0x15</span>,<span class="number">0x08</span>,<span class="number">0x16</span>,<span class="number">0x61</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*,1*/</span></span><br><span class="line"><span class="string">&quot;世&quot;</span>,</span><br><span class="line"><span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFE</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x47</span>,<span class="number">0x44</span>,<span class="number">0x44</span>,<span class="number">0x44</span>,<span class="number">0x47</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="comment">/*,2*/</span></span><br><span class="line"><span class="string">&quot;界&quot;</span>,</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0xFE</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0x92</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x84</span>,<span class="number">0x62</span>,<span class="number">0x1E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="comment">/*,3*/</span></span><br><span class="line"><span class="string">&quot;    &quot;</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line"><span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将中文字模储存到OLED_CF_16_16里面就可以了。</p>
<p>以上的内容都是无缓冲区实现OLED显示的，无缓冲区的缺点就是不能在两个页码之间显示数据，只能上下两个页码同时写满。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="对射红外传感器计次"><a href="#对射红外传感器计次" class="headerlink" title="对射红外传感器计次"></a>对射红外传感器计次</h3><p>这里跟51单片机的定时器情况类似，32就直接引入了中断的概念，像我的stm32f103有68种中断函数，有硬件中断也有定时器中断还有EXIT中断等等。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1735054774083.png" alt="1735054774083"></p>
<p>这就是EXIT中断的简要流程图，我们也需要根据图上的内容来依次配置寄存器，用hal库。</p>
<p>首先第一个是AFIO，AFIO的作用是从多个GPIO接口中筛选出一个16接口来交给EXIT，避免线太多的麻烦，所以在配置EXIT中断时，选择监视的接口的端口位数不能有重复的，就比如不能同时设置GPIO_PinB1和GPIO_PinA1同时作为EXIT检测的io口，这样会出错。</p>
<p>然后就是EXIT的设置，跟GPIO的初始化配置类似，先是定义一个结构体，然后再交给hal库取值处理。</p>
<p>最后就是NVIC，这个东西的作用就是起到全局调度，设置好中断优先级以后，NVIC会配置好中断步骤，然后再交给。中断优先级可以分为抢占优先级和子优先级，其中抢占优先级是可以进行中断嵌套的，而子优先级的中断只能当本次中断执行结束后再执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);		<span class="comment">//AFIO配置</span></span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructre;</span><br><span class="line">	EXTI_InitStructre.EXTI_LineCmd = ENABLE;					<span class="comment">//打开使能</span></span><br><span class="line">	EXTI_InitStructre.EXTI_Mode = EXTI_Mode_Interrupt;			<span class="comment">//设置中断模式还是事件模式</span></span><br><span class="line">	EXTI_InitStructre.EXTI_Trigger = EXTI_Trigger_Falling;		<span class="comment">//下降沿触发模式</span></span><br><span class="line">	EXTI_InitStructre.EXTI_Line = EXTI_Line14;					<span class="comment">//设置具体的线</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructre);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;<span class="comment">//NVIC通道</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//NVIC使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//NVIC权限设置，数字越小越先执行</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line14)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		CountSensor_Count++;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line14);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这就是简单的一个光线传感器的计数模块，利用了中断函数进行计数。</p>
<h3 id="旋转编码计次"><a href="#旋转编码计次" class="headerlink" title="旋转编码计次"></a>旋转编码计次</h3><p>这里用到了一个简单的旋转编码器，在连接vcc跟gnd和两个信号传输线后就可以正常使用了。有A相和B相输出，其中两向之间存在相位差，正转：如果A相先于B相变化，则表示编码器正转。反转：如果B相先于A相变化，则表示编码器反转。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Encoder_Count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);</span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">	EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;</span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int16_t</span> Temp;</span><br><span class="line">	Temp = Encoder_Count;</span><br><span class="line">	Encoder_Count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count --;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line1) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编码器核心代码如上，当触发中断的时候，快速判断另一个头是不是低电平，来实现判断正转和反转，并进行+1和-1的操作。在主程序中只用num+&#x3D;Encoder_Get()即可，并打印出num的值。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器是stm32中的重要组成部分之一，跟51单片机有所不同，stm32中的定时器是从0开始向上计数，最大可以计数计到65535，我们要设置的通常是设置计到多少就触发中断，比如说可以设置1000-1，-1则是因为定时器的计数是从0开始计算的，所以需要-1才可以真实的达到1000.</p>
<p>先来张定时器原理图。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1743941133773.jpg" alt="1743941133773"></p>
<p>一般我们使用的都是内部时钟，这里的重点是时基单元的配置，第一是预分频器，预分频器就相当于把晶振的频率先做一次处理，然后再进行计数，如果计数的值达到了自动重装器的目标值，就进入中断。同样，定时器也与nvic的中断优先级的设置。</p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>先上张PWM的原理图。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1743941133763.jpg" alt="1743941133763"></p>
<p>本质上就是在定时器的后面加上了一个输出比较。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/1743941133769.jpg" alt="1743941133769"></p>
<p>这是输出比较模式的配置，基本上就是使用PWM模式1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_Initstructure;</span><br><span class="line">	GPIO_Initstructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_Initstructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_Initstructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_Initstructure);		<span class="comment">//GPIo初始化</span></span><br><span class="line">	</span><br><span class="line">	TIM_InternalClockConfig(TIM2);<span class="comment">//设置TIM2为内部时钟源</span></span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;</span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//设置时钟源分频</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//设置为向上开始计数的模式</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_Period = <span class="number">100</span><span class="number">-1</span>;<span class="comment">//自动重装的值，就是计数达到这个值触发中断</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">	TIM_TimeBaseInitStruct.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//高级定时器中的重复计数器，这里不用，设置为0</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStruct);			<span class="comment">//时基单元配置</span></span><br><span class="line">	</span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStruct;</span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStruct);<span class="comment">//初始化结构体，设置其他的为默认参数</span></span><br><span class="line">	TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;<span class="comment">//设置输出比较模式</span></span><br><span class="line">	TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;<span class="comment">//设置有效电平为高电平</span></span><br><span class="line">	TIM_OCInitStruct.TIM_Pulse = <span class="number">0</span>;<span class="comment">//设置比较器，就是定时器计数到多少的时候触发</span></span><br><span class="line">	TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">	TIM_OC1Init(TIM2,&amp;TIM_OCInitStruct);		<span class="comment">//PWM模式配置</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM2,ENABLE);		<span class="comment">//开启定时器</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_Set2Compare1</span><span class="params">(<span class="type">uint16_t</span> compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare1(TIM2,compare);		<span class="comment">//设置PWM的比较器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的是PWM.c的配置，封装了一些基本的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;PWM.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	PWM_Init();</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=0;i&lt;=100;i++)&#123;</span><br><span class="line">			TIM_Set2Compare1(i);</span><br><span class="line">			Delay_ms(10);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=0;i&lt;=100;i++)&#123;</span><br><span class="line">			TIM_Set2Compare1(100-i);</span><br><span class="line">			Delay_ms(10);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是主函数的配置，通过delay加上合理设置PWM的输出比较器，最终实现呼吸灯的效果。</p>
<p>呼吸灯还有另一个改进的版本，就是使用了两个定时器来完成呼吸灯的操作，一个是用来输出PWM信号，还有一个定时器是用来延时，具体的作用就是上述第一个版本的定时器的这个代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Delay_ms(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>



<p>具体函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) &#123;</span><br><span class="line">        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);</span><br><span class="line">        <span class="comment">// 在此处添加需要定时执行的代码</span></span><br><span class="line">        <span class="keyword">if</span> (pwmEnabled) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">uint8_t</span> direction = <span class="number">0</span>;</span><br><span class="line">            <span class="type">static</span> <span class="type">uint16_t</span> pwmValue = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 呼吸灯效果逻辑（示例）</span></span><br><span class="line">            <span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">                pwmValue += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pwmValue &gt;= <span class="number">100</span>) direction = <span class="number">1</span>;  <span class="comment">// 假设PWM周期为1000</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pwmValue -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pwmValue == <span class="number">0</span>) direction = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新PWM占空比（假设使用TIM2_CH1）</span></span><br><span class="line">            TIM_SetCompare1(TIM2, pwmValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就是这样子设置一个10ms的定时器，没10ms就会跑一下这个程序，这个10ms是至关重要的，如果不设置这个10ms，那么就不会有呼吸灯的效果了，就只会保持一个中等的亮度，有了人为加的10ms，延长了时间，人眼看上去就不是一个恒定的亮度。</p>
<h2 id="ADC数模转换"><a href="#ADC数模转换" class="headerlink" title="ADC数模转换"></a>ADC数模转换</h2><p>ADC就是一种可以把连续的电信号转化为数字形式的离散信号的方式，像32单片机对ADC有着很好的支持，有专门的功能支持ADC的实现。</p>
<p>先放张ADC的配置过程图。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/31E50140E4B6864A74B390B588510B62.jpg" alt="31E50140E4B6864A74B390B588510B62"></p>
<p>首先还是先选择输入的模式，可以选GPIO的信号也可以选择内部外设的温度传感器作为信号源，这个对应的就是ADC的channel的选择，然后就进入规则组和注入组的配置还有一些基本的参数配置，这些也都是在官方库中以结构体的形式传递参数。然后可以选择模拟看门狗的配置，可以达到一定的值以后触发看门狗，挺方便的，也可以继续接入中断，触发中断去执行其他任务。</p>
<p>下面的触发控制可以选择定时器触发或者中断触发，也可以选择软件触发，我们使用的就是软件触发，RCC则用的是内部72mzh的时钟。</p>
<p>下面是具体代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_Initstructure;</span><br><span class="line">	GPIO_Initstructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_Initstructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_Initstructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_Initstructure);		<span class="comment">//GPIO初始化</span></span><br><span class="line">	</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);<span class="comment">//选择采样时间和频道，这里的频道设置要慎重选择，不同频道对应不用的io口</span></span><br><span class="line">	</span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;<span class="comment">//是否连续采样，就是不断循环读取值</span></span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<span class="comment">//选择触发源，这里的noone就是软件触发</span></span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;<span class="comment">//ADC模式，这里的是单ADC模式</span></span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>;<span class="comment">//转换通道设置，就是你有多少条数据需要ADC转换</span></span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = DISABLE;<span class="comment">//扫描模式设置，选择扫描一个通道还是多个通道</span></span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);		<span class="comment">//ADC使能</span></span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);<span class="comment">//重置校验器</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)==SET);<span class="comment">//等待重置完成</span></span><br><span class="line">	ADC_StartCalibration(ADC1);<span class="comment">//启用校验器</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1)==SET);			<span class="comment">//等待校验完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);		<span class="comment">//软件触发</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);</span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);		<span class="comment">//读取转换的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大致如上了，这些代码就可以实现对PA0口的输入的电压进行数模转换，如果想要调成其他io口，就需要翻手册，不同的对应的io口都有不同的channel值设置。</p>
<p>如果想对多个io口进行数模转化，也不难，对它们进行扫描就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">uint8_t</span> ADC_Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);</span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以将AD数据的读取函数设置成这个样子就可以了，在主函数里面依次读取不同channel的数值，并且储存到变量里面就可以了。</p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA是一种计算机系统中的数据传输技术，允许某些硬件子系统（如硬盘控制器、网络接口卡、声卡等）在不依赖中央处理器（CPU）的情况下，直接与系统的主内存（RAM）进行数据交换。这种技术的主要目的是<strong>提高数据传输效率</strong> ，减轻CPU的负担。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-09_15-11-49.png" alt="PixPin_2025-04-09_15-11-49"></p>
<p>这是DMA的核心原理图，我们需要配置的基本都在这个上面了。</p>
<p>下面是一个DMA使用案列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> Addra,<span class="type">uint32_t</span> Addrb,<span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;	</span><br><span class="line"></span><br><span class="line">	MyDMA_Size = Size;</span><br><span class="line">	</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = Size;<span class="comment">//自动重装</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//方向设置，从外设作为出发地址</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Enable;<span class="comment">//设置为软件触发</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = Addrb;<span class="comment">//存储器地址</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;<span class="comment">//存储器的数据宽度</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Normal;<span class="comment">//循环模式，有单次和无限循环的区别</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = Addra;<span class="comment">//外设地址</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//外设的数据宽度</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="comment">//外设地址是否自增</span></span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;<span class="comment">//DMA级别设置，用于多个DMA之间选择先后</span></span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);		<span class="comment">//改变传输计数器的值，需要先失能DMA然后再使能才能生效</span></span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1)==RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);		<span class="comment">//一旦查看了DMA的状态值就要记得清除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是主函数配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">#include &quot;OLED.h&quot;</span><br><span class="line">#include &quot;Mydma.h&quot;</span><br><span class="line">uint8_t dataa[]=&#123;1,2,3,4&#125;;</span><br><span class="line">uint8_t datab[]=&#123;0,0,0,0&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	MyDMA_Init((uint32_t)dataa,(uint32_t)datab,4);</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;	</span><br><span class="line">		dataa[0]++;</span><br><span class="line">		dataa[1]++;</span><br><span class="line">		dataa[2]++;</span><br><span class="line">		dataa[3]++;</span><br><span class="line">		OLED_ShowHexNum(1,1,dataa[0],2);</span><br><span class="line">		OLED_ShowHexNum(1,4,dataa[1],2);</span><br><span class="line">		OLED_ShowHexNum(1,7,dataa[2],2);</span><br><span class="line">		OLED_ShowHexNum(1,10,dataa[3],2);</span><br><span class="line">		OLED_ShowHexNum(2,1,datab[0],2);</span><br><span class="line">		OLED_ShowHexNum(2,4,datab[1],2);</span><br><span class="line">		OLED_ShowHexNum(2,7,datab[2],2);</span><br><span class="line">		OLED_ShowHexNum(2,10,datab[3],2);</span><br><span class="line">		Delay_ms(1000);</span><br><span class="line">		MyDMA_Transfor();</span><br><span class="line">		OLED_ShowHexNum(3,1,dataa[0],2);</span><br><span class="line">		OLED_ShowHexNum(3,4,dataa[1],2);</span><br><span class="line">		OLED_ShowHexNum(3,7,dataa[2],2);</span><br><span class="line">		OLED_ShowHexNum(3,10,dataa[3],2);</span><br><span class="line">		OLED_ShowHexNum(4,1,datab[0],2);</span><br><span class="line">		OLED_ShowHexNum(4,4,datab[1],2);</span><br><span class="line">		OLED_ShowHexNum(4,7,datab[2],2);</span><br><span class="line">		OLED_ShowHexNum(4,10,datab[3],2);</span><br><span class="line">		Delay_ms(1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样就可以清楚的看到DMA的传输数据的过程。</p>
<h2 id="DMA与ADC相结合"><a href="#DMA与ADC相结合" class="headerlink" title="DMA与ADC相结合"></a>DMA与ADC相结合</h2><p>在实际使用过程中，因为ADC数模转换的速度非常快，而且如果用的是规则组，只有一个寄存器来读取数据，所以我们需要DMA来帮助我们快速转运数据到其他位置，防止数据被覆盖而丢失。</p>
<p>虽然ST并没有写单个ADC通道转换完成，我们只能拿到一系列的ADC通道转换完成的返回，但是ST非常贴心的给出了ADC和DMA的交互通道，可以做到每个通道一转换完成，就可以通知DMA进行数据转移。</p>
<p>下面是一个使用案例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint16_t</span> data[<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_Initstructure;</span><br><span class="line">	GPIO_Initstructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_Initstructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">	GPIO_Initstructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_Initstructure);</span><br><span class="line">	</span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>;</span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = ENABLE;</span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="number">1</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_1,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line"></span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>;<span class="comment">//自动重装（因为ADC开启了两个通道，所以DMA也转运两次）</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//方向</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Disable;<span class="comment">//因为是硬件触发，所以设置disable</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)&amp;data[<span class="number">0</span>];</span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	ADC_DMACmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)==SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1)==SET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Getvalue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,<span class="number">2</span>);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1)==RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个代码的实现就需要把**AD_Getvalue()**这个函数放到while1里面不断循环设置DMA和软件触发ADC。</p>
<p>得到的数据就全部存在了data的数组里面，把这个数组在.h文件里面声明一下，就可以在主函数直接读取并且使用了。</p>
<p>其实还可以做一些配置，比如修改一下代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADC_SoftwareStartConvCmd(ADC1,ENABLE);</span><br></pre></td></tr></table></figure>



<p>1.把这个函数放在MyDMA_Init()里面；</p>
<p>2.然后将ADM和DMA都改成自动的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;</span><br></pre></td></tr></table></figure>



<p>这样子只要在调用一次MyDMA_Init()函数，就可以先软件触发ADC，然后ADC和DMA无限循环监测并转移数据了。</p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>先介绍几个通信的方式和概念吧。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-11-00-10-44-728_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-11-00-10-44-728_tv.danmaku.bil"></p>
<p>解释一些概念：</p>
<ol>
<li>双工：这是根据通信双方的传输方式决定的，分为单工，全双工和半双工，其中，单工就是只有单向通信，半双工指的是可以双向通信，但不能同时进行通信，而全双工则是可以同时进行双向通信。</li>
<li>时钟：异步指的是双方的通信不需要额外的时钟线，就是不需要时钟来同步数据传输，而同步则是需要时钟。</li>
<li>电平：就是指双方通信区分高低电平的方法，单端则是根据他们相对于同一个电平来区分，这个标准电平通常是GND，而差分电平就是通过两个电平的差分值来判断高低电平。差分的方式比较稳定。</li>
</ol>
<p>这些都是一些比较常见的单片机传输协议，各有各的优点和特色吧。</p>
<h3 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h3><p>USART就是我们通常所说的串口通信。把hex文件烧录到单片机中，就使用了串口通信，和ch340这个usb转串口通信的芯片。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-11-00-28-17-826_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-11-00-28-17-826_tv.danmaku.bil"></p>
<p>这是串口的一些参数和时序图，我们需要设置合适的参数。</p>
<p>一般选用的模式都是9字符带校验位的模式或者8字符不带校验位的模式。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-12_01-05-08.png" alt="PixPin_2025-04-12_01-05-08"></p>
<p>这是USART的配置流程图，其中的TX和RX都是有与之相对应的GPIO口的，这些都是手册里写死的。</p>
<p>最开始都是先开启内部时钟并设置好分频以供发送和接收器的使用，并且发送和接受都有一个寄存器做好了缓存，避免数据覆盖，只有当数据完全写入或者读取后，才会写入新的数据。</p>
<h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>这是发送数据的函数代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//设置波特率</span></span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//关闭硬件流配置</span></span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx;<span class="comment">//选择模式</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;<span class="comment">//设置校验位</span></span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位设置</span></span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//设置数据大小</span></span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> byte)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(USART1,byte);</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *<span class="built_in">array</span>,<span class="type">uint16_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint16_t</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(<span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(String[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>接收和发送大致相同，就改了几行的配置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;<span class="comment">//加上RX模式</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主函数里的while1里面再这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">	&#123;</span><br><span class="line">		data = USART_ReceiveData(USART1);</span><br><span class="line">	&#125;</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,data,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<p>就可以实现对接收到的数据进行读取的操作了。</p>
<p>还可以使用中断，只需要加上这行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br></pre></td></tr></table></figure>

<p>并且配置好nvic就可以使用中断了。</p>
<h3 id="USART发送接收数据包"><a href="#USART发送接收数据包" class="headerlink" title="USART发送接收数据包"></a>USART发送接收数据包</h3><p>前文的发送和接收的都是只能发送和接收单字节，下面将实现对一个数据包的发送和接收。因为发送比较简单，拼出发送一个字符串就可以了。所有主要写的还是接收数据包。</p>
<p>首先先说明一下数据包。</p>
<p>数据包有两种形式，一个是固定长度，还有一个是不固定长度，但是不论哪种形式，都需要定义包头和包尾，发送的内容也可以是hex模式（即16进制的模式），和文本模式，即发送已经编码后的文本。</p>
<p>下面是一张不固定长度的文本模式的数据包构造，可以看到图中的包头是“ @ ” ， 包尾是 “\r\n”（这是windows系统的换行符） ，图中也写明了如何定义接收的函数，就是通过状态机的思想，通过不同的状态来控制整个的接收流程。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-14-11-20-55-840_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-14-11-20-55-840_tv.danmaku.bil"></p>
<p>下面是一个程序实例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint8_t</span> USARTStatu;</span><br><span class="line"><span class="type">uint8_t</span> RXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> TXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;</span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">USART_Getflag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(USARTStatu==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		USARTStatu=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState=<span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> pRxState=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">uint8_t</span> Rxdata = USART_ReceiveData(USART1);</span><br><span class="line">		<span class="keyword">if</span>(RxState==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="number">0xFF</span>)</span><br><span class="line">				RxState=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			RXPack[pRxState] = Rxdata;</span><br><span class="line">			pRxState++;</span><br><span class="line">			<span class="keyword">if</span>(pRxState&gt;=<span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="number">0xFE</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">0</span>;</span><br><span class="line">				USARTStatu=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		USART_ClearITPendingBit(USART1,USART_IT_RXNE);<span class="comment">//清楚标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个固定长度的hex数据包的接收，其中包头是 “0xFF” ，包尾是 “0xFE” 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(USART_Getflag()==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,RXPack[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">3</span>,RXPack[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">5</span>,RXPack[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">    OLED_ShowHexNum(<span class="number">1</span>,<span class="number">7</span>,RXPack[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在主函数的while循环里执行这条语句，就可以不断读取接收到的数据，并且显示在oled屏幕上了。</p>
<p>还有无固定大小文本模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">uint8_t</span> USARTStatu=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line"><span class="type">uint8_t</span> RXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> TXPack[<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line"> 	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;</span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState=<span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> pRxState=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==SET)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">uint8_t</span> Rxdata = USART_ReceiveData(USART1);</span><br><span class="line">		<span class="keyword">if</span>(RxState==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="string">&#x27;@&#x27;</span> &amp;&amp; USARTStatu==<span class="number">0</span>)</span><br><span class="line">				RxState=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Rxdata==<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">				RxState=<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				data[pRxState] = Rxdata;</span><br><span class="line">				pRxState++;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Rxdata==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			RxState = <span class="number">0</span>;</span><br><span class="line">			data[pRxState] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			pRxState=<span class="number">0</span>;</span><br><span class="line">			USARTStatu=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个有效地防止了数据包的错位，直接引入了USARTStatu的判定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	Serial_Init();</span><br><span class="line">	LED_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(USARTStatu==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,data);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(data,<span class="string">&quot;LEDON&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				LED1_ON();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(data,<span class="string">&quot;LEDOF&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				LED1_OFF();</span><br><span class="line">			&#125;</span><br><span class="line">			USARTStatu=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中做一下数据的处理，就可以很方便的完成电脑输入命令然后对里面的内容进行控制了。</p>
<h3 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h3><p>IIC是一种通信协议，是一个同步半双工通信，用途非常广，只需要SCL和SDA两根线就可以完成数据的同步传输，因为是同步的协议，所以可以随时开始通信也可以随时停止通信，而且可以一个主多从，一个主机可以和多个从机进行交互。</p>
<p>先介绍一下基本的通信流程吧。</p>
<p>一开始初始因为有一个上拉电阻，处于一个弱上拉的状态，所以呈现的状态是高电平。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_11-43-18.png" alt="PixPin_2025-04-23_11-43-18"></p>
<p>这是开始和结束的时序图，当主机准备开始通信的时候，就会在保持SCL高电平的同时，拉低SDA。主机在准备结束通信的时候，就会在SCL保持高电平的时候，回弹SDA。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_12-07-23.png" alt="PixPin_2025-04-23_12-07-23"></p>
<p>这是发送一个字节的时序。  在SCL在低电平的时间，主机快速把数据放在SDA上，等到SCL回弹到高电平之后，从机就会读取SDA的电平状态来判断0还是1，然后主机再拉低SCL，如此反复执行8次，就可以发送一个字节的时序。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_12-25-47.png" alt="PixPin_2025-04-23_12-25-47"></p>
<p>这是接收一个字节的时序。在SCL在低电平的时间，从机快速把数据放在SDA上，主机再把SCL置为高电平并且此时读取SDA的电平状态判断是0还是1，也是循环8次，接收一个字节（主机在接收前需要回弹SDA）。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-23_13-17-07.png" alt="PixPin_2025-04-23_13-17-07"></p>
<p>这是发送应答和接收应答的时序。当每完成一个字节的数据传输以后，就会开启应答来确认一下是否接收到了数据。其中，在主机接收应答前，需要把SDA的电平拉下来，然后从机如果接收到了数据，需要立马将SDA回弹至高电平，只有这样才算接收到了数据。</p>
<p>这些就是IIC通信的基本单元，下面是一个完整的IIC发送流程：</p>
<ol>
<li>主机先发送开始信号。</li>
<li>主机继续发送选择从机的地址码加上发送还是接收选择，其中，地址码通常是一个7位的二进制数据，然后模式选择是选择发送还是接收，其中0表示写，1表示读，拼接起来就是一个8位一个字节的数据。</li>
<li>然后就是发送数据，发送一个字节的数据，从机依次接收数据。（这个数据可以是需要写入的地址或者写入的数据，这个具体看从机的要求）</li>
<li>从机发送ack表示已经接收到了数据。</li>
<li>最后主机可以选择发送stop终止信号。</li>
</ol>
<p>下面是一个完整的IIC接收流程：</p>
<ol>
<li>主机先发送开始信号。</li>
<li>一样的主机发送从机的地址码加一个0。</li>
<li>发送你要读取的寄存器的地址，从机会应答。</li>
<li>重复起始条件。</li>
<li>发送从机地址加1，切换到读的模式。</li>
<li>从机控制SDA线，主机读取SDA线以获取数据，如果需要继续发送，主机发送ACK就行了，如果终止发送，主机发送NACK。</li>
<li>最后主机发送stop终止信号。</li>
</ol>
<h4 id="软件模拟IIC"><a href="#软件模拟IIC" class="headerlink" title="软件模拟IIC"></a>软件模拟IIC</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_W_SCL</span><span class="params">(<span class="type">uint8_t</span> Bitvalue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB,GPIO_Pin_10,(BitAction)Bitvalue);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_W_SDA</span><span class="params">(<span class="type">uint8_t</span> Bitvalue)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOB,GPIO_Pin_11,(BitAction)Bitvalue);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Myi2c_R_SDA</span><span class="params">()</span><span class="comment">//封装了一些基本的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> Bitvalue;</span><br><span class="line">	Bitvalue = GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11);</span><br><span class="line">	Delay_us(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> Bitvalue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_SetBits(GPIOB,GPIO_Pin_10 | GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SDA(<span class="number">0</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Myi2c_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">0</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2c_sendbyte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Myi2c_W_SDA(Byte &amp; (<span class="number">0x80</span>&gt;&gt;i));</span><br><span class="line">		Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">		Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2c_receivebyte</span><span class="params">()</span><span class="comment">//发送一个字节的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i,Byte = <span class="number">0x00</span>;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(Myi2c_R_SDA() == <span class="number">1</span>)&#123;Byte |= (<span class="number">0x80</span>&gt;&gt;i);&#125;;</span><br><span class="line">		Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2c_sendack</span><span class="params">(<span class="type">uint8_t</span> ackbit)</span></span><br><span class="line">&#123;	</span><br><span class="line">		Myi2c_W_SDA(ackbit);</span><br><span class="line">		Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">		Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2c_receiveack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ackbit;</span><br><span class="line">	Myi2c_W_SDA(<span class="number">1</span>);</span><br><span class="line">	Myi2c_W_SCL(<span class="number">1</span>);</span><br><span class="line">	ackbit = Myi2c_R_SDA();</span><br><span class="line">	Myi2c_W_SCL(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> ackbit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是软件模拟IIC的基本函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	MyI2C_Init();</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(<span class="number">0xD0</span>);</span><br><span class="line">	<span class="type">uint8_t</span> ack = MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">	OLED_ShowNum(<span class="number">1</span>,<span class="number">1</span>,ack,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个简单的使用例子，发送了选择从机的字节后接收回应，正确的显示应该是000。</p>
<h5 id="IIC加MPU6050"><a href="#IIC加MPU6050" class="headerlink" title="IIC加MPU6050"></a>IIC加MPU6050</h5><p>MPU6050是一个比较出名的运动处理传感器，它有着三轴陀螺仪传感器和三轴加速度传感器，可以测算出芯片的姿态，应用非常广泛，其中它的通信方式就是通过IIC与主机进行通信。</p>
<p>下面是基于上节所写的IIC基本代码而完成的MPU6050库函数编写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">#include &quot;myiic.h&quot;</span><br><span class="line">#include &quot;MPU6050_Reg.h&quot;</span><br><span class="line">#define MPU6050_ADDRESS 0xD0</span><br><span class="line">void MPU6050_WriteReg(uint8_t RegAddress,uint8_t Data)</span><br><span class="line">&#123;</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(MPU6050_ADDRESS);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(RegAddress);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(Data);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t MPU6050_ReadReg(uint8_t RegAddress)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t Data;</span><br><span class="line">	</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(MPU6050_ADDRESS);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	MyI2c_sendbyte(RegAddress);</span><br><span class="line">	MyI2c_receiveack();//第一次发送，将地址指针移动到想要读取数据的位置</span><br><span class="line">	</span><br><span class="line">	Myi2c_start();</span><br><span class="line">	MyI2c_sendbyte(MPU6050_ADDRESS | 0x01);</span><br><span class="line">	MyI2c_receiveack();</span><br><span class="line">	Data = MyI2c_receivebyte();</span><br><span class="line">	MyI2c_sendack(1);</span><br><span class="line">	Myi2c_stop();</span><br><span class="line">	</span><br><span class="line">	return Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MPU6050_Init()</span><br><span class="line">&#123;</span><br><span class="line">	MyI2C_Init();</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_1,0x01);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_2,0x00);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_SMPLRT_DIV,0x09);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_CONFIG,0x06);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_GYRO_CONFIG,0x18);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,0x18);//根据手册写的基本的MPU6050的寄存器配置</span><br><span class="line">&#125;</span><br><span class="line">void MPU6050_Getdata(int16_t *AccX,int16_t *AccY,int16_t *AccZ,int16_t *GyroX,int16_t *GyroY,int16_t *GyroZ)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t DataH,DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">	*AccX = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">	*AccY = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">	*AccZ = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">	*GyroX = (DataH&lt;&lt;8) | DataL;</span><br><span class="line"></span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">	*GyroY = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">	DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">	DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">	*GyroZ = (DataH&lt;&lt;8) | DataL;</span><br><span class="line">	</span><br><span class="line">&#125;//读取对应的寄存器的值</span><br></pre></td></tr></table></figure>



<p>调用的话就在主函数里面声明这些变量，然后while里面不断获取数据就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	MPU6050_Init();</span><br><span class="line">	<span class="type">int16_t</span> ax,ay,az,gx,gy,gz;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MPU6050_Getdata(&amp;ax,&amp;ay,&amp;az,&amp;gx,&amp;gy,&amp;gz);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">1</span>,ax,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">1</span>,ay,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">1</span>,az,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">8</span>,gx,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">3</span>,<span class="number">8</span>,gy,<span class="number">5</span>);</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">4</span>,<span class="number">8</span>,gz,<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子就可以在OLED上看到不断打印出的数据了。</p>
<h4 id="硬件模拟IIC"><a href="#硬件模拟IIC" class="headerlink" title="硬件模拟IIC"></a>硬件模拟IIC</h4><p>stm32f103系列自带了有两个IIC的外设，对应的是IIC1和IIC2，硬件控制比软件模拟就相对舒服很多了，库函数也提供了很成熟的函数支持IIC通信，与GPIO等常用外设初始化一样，IIC的初始化也是通过构造结构体并且传入数值来进行设置。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-24-09-00-29-587_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-24-09-00-29-587_tv.danmaku.bil"></p>
<p>这是IIC的配置流程，基本上按照流程图配置完寄存器就可以了。</p>
<p>IIC外设的寄存器分为三种，第一个是CR，控制寄存器，就是对IIC外设进行基本设置的寄存器，第二个是DR，数据寄存器，就是存储IIC接收到的数据的寄存器，不管是发送还是接收数据，都会用到这个DR寄存器，第三个是SR，状态寄存器，专门用来读取IIC的状态的，方便对IIC的工作做出基本的判断和调控。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-25_13-22-47.png" alt="PixPin_2025-04-25_13-22-47"></p>
<p>这是发送时序的流程图，其中EVx就是可以通过状态寄存器SR进行读取的。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-25_13-23-07.png" alt="PixPin_2025-04-25_13-23-07"></p>
<p>这是接收器的时序图，写代码按照这个图上的流程进行基本的配置就可以了，st官方的库函数已经封装好了相对成熟的函数方便我们进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT) != SUCCESS);</span><br><span class="line">	I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) != SUCCESS);</span><br><span class="line">	I2C_SendData(I2C2,RegAddress);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) != SUCCESS);</span><br><span class="line">	I2C_SendData(I2C2,Data);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTING) != SUCCESS);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) != SUCCESS);</span><br><span class="line">	I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> Data;</span><br><span class="line">	I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT) != SUCCESS);</span><br><span class="line">	I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Transmitter);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) != SUCCESS);</span><br><span class="line">	I2C_SendData(I2C2,RegAddress);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_TRANSMITTED) != SUCCESS);</span><br><span class="line">	I2C_GenerateSTART(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_MODE_SELECT) != SUCCESS);	</span><br><span class="line">	I2C_Send7bitAddress(I2C2,MPU6050_ADDRESS,I2C_Direction_Receiver);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) != SUCCESS);</span><br><span class="line">	I2C_AcknowledgeConfig(I2C2,DISABLE);</span><br><span class="line">	I2C_GenerateSTOP(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">while</span>(I2C_CheckEvent(I2C2,I2C_EVENT_MASTER_BYTE_RECEIVED) != SUCCESS);</span><br><span class="line">	Data = I2C_ReceiveData(I2C2);</span><br><span class="line">	I2C_AcknowledgeConfig(I2C2,ENABLE);</span><br><span class="line">	<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	I2C_Init();</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	I2C_InitTypeDef I2C_InitStruct;</span><br><span class="line">	I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">	I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">	I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</span><br><span class="line">	I2C_InitStruct.I2C_ClockSpeed = <span class="number">10000</span>;</span><br><span class="line">	I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_16_9;</span><br><span class="line">	I2C_InitStruct.I2C_OwnAddress1 = <span class="number">0x00</span>;</span><br><span class="line">	I2C_Init(I2C2,&amp;I2C_InitStruct);</span><br><span class="line">	</span><br><span class="line">	I2C_Cmd(I2C2,ENABLE);</span><br><span class="line">	</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_CONFIG,<span class="number">0x06</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_GYRO_CONFIG,<span class="number">0x18</span>);</span><br><span class="line">	MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是针对上一节的软件模拟IIC实现MPU6050的读取的优化，如果担心while会陷入死循环的话，可以再封装一个等待函数，可以尝试10000–这种操作，如果超时就强行退出。</p>
<h3 id="spi通信"><a href="#spi通信" class="headerlink" title="spi通信"></a>spi通信</h3><p>spi通信有四根线，分别是MOSI，MOSO，SLK，SS。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MOSI</td>
<td align="center">主机发送</td>
</tr>
<tr>
<td align="center">MOSO</td>
<td align="center">主机接收</td>
</tr>
<tr>
<td align="center">SLK</td>
<td align="center">时钟线，由主机完全控制</td>
</tr>
<tr>
<td align="center">SS</td>
<td align="center">设备选择线，低电平表示选中设备</td>
</tr>
</tbody></table>
<p>spi相对iic来说要简单一些，因为它的线比较多，所以没有这么多限制条件，下图是spi通信的原理，本质上发送和接收是一体的，同时发送同时接收，就是通过一位一位的移，差不多是一个循环模式。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/Screenshot_2025-04-27-09-17-16-594_tv.danmaku.bil.jpg" alt="Screenshot_2025-04-27-09-17-16-594_tv.danmaku.bil"></p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-04-30_10-55-23.png" alt="PixPin_2025-04-30_10-55-23"></p>
<p>这是最常用的模式0的时序，模式0就是上升沿读取数据，下降沿准备数据，并且SCK空闲的时候为低电平，总共有四种模式选择，就是CPOL和CPHA的不同组合，最常用的还是模式0。</p>
<h4 id="软件模拟spi"><a href="#软件模拟spi" class="headerlink" title="软件模拟spi"></a>软件模拟spi</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_ss</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_sck</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_5,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_mosi</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line"></span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_7,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">myspi_r_miso</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">	myspi_w_sck(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">myspi_swapbyte</span><span class="params">(<span class="type">uint8_t</span> bytesend)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> received_byte = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送最高位</span></span><br><span class="line">        myspi_w_mosi((bytesend &amp; <span class="number">0x80</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 拉高时钟，从设备在上升沿采样MOSI数据</span></span><br><span class="line">        myspi_w_sck(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取MISO数据（在时钟高电平期间有效）</span></span><br><span class="line">        received_byte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (myspi_r_miso() == <span class="number">1</span>) &#123;</span><br><span class="line">            received_byte |= <span class="number">0x01</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拉低时钟，准备下一位</span></span><br><span class="line">        myspi_w_sck(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 准备发送下一位</span></span><br><span class="line">        bytesend &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> received_byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过myspi_swapbyte函数，就可以交换一个字节，以达到通信的效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myspi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;w25q64_ins.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_Init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_readid</span><span class="params">(<span class="type">uint8_t</span> *MID,<span class="type">uint16_t</span> *DID)</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_JEDEC_ID);</span><br><span class="line">	*MID = myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	*DID = myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	*DID &lt;&lt;=<span class="number">8</span>;</span><br><span class="line">	*DID |= myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	myspi_stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_write_enable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_WRITE_ENABLE);</span><br><span class="line">	myspi_stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_wait_busy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_READ_STATUS_REGISTER_1);</span><br><span class="line">	<span class="keyword">while</span>((myspi_swapbyte(W25Q64_DUMMY_BYTE)&amp; <span class="number">0x01</span>)==<span class="number">0x01</span>);</span><br><span class="line">	myspi_stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_pageprogram</span><span class="params">(<span class="type">uint32_t</span> address,<span class="type">uint8_t</span> *data,<span class="type">uint16_t</span> count)</span></span><br><span class="line">&#123;	</span><br><span class="line">	w25q64_write_enable();</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_PAGE_PROGRAM);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	myspi_swapbyte(address);</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		myspi_swapbyte(data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	myspi_stop();</span><br><span class="line">	w25q64_wait_busy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_sector_erase</span><span class="params">(<span class="type">uint32_t</span> address)</span></span><br><span class="line">&#123;	</span><br><span class="line">	w25q64_write_enable();</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	myspi_swapbyte(address);</span><br><span class="line">	myspi_stop();</span><br><span class="line">	w25q64_wait_busy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w25q64_readdata</span><span class="params">(<span class="type">uint32_t</span> address,<span class="type">uint8_t</span> *data,<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_start();</span><br><span class="line">	myspi_swapbyte(W25Q64_READ_DATA);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">16</span>);</span><br><span class="line">	myspi_swapbyte(address&gt;&gt;<span class="number">8</span>);</span><br><span class="line">	myspi_swapbyte(address);</span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data[i] = myspi_swapbyte(W25Q64_DUMMY_BYTE);</span><br><span class="line">	&#125;</span><br><span class="line">	myspi_stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是基于spi底层所写的关于w25q64的使用函数封装，spi通信很多都是按照对应的外设发送设定好的命令来做一些交互。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>   <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;w25q64.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> MID;</span><br><span class="line"><span class="type">uint16_t</span> DID;</span><br><span class="line"><span class="type">uint8_t</span> dataw[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> datar[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	OLED_Init();</span><br><span class="line">	w25q64_Init();</span><br><span class="line">	w25q64_readid(&amp;MID,&amp;DID);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>,<span class="number">1</span>,MID,<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>,<span class="number">5</span>,DID,<span class="number">4</span>);</span><br><span class="line">	w25q64_sector_erase(<span class="number">0x000000</span>);</span><br><span class="line">	w25q64_pageprogram(<span class="number">0x0000000</span>,dataw,<span class="number">4</span>);</span><br><span class="line">	w25q64_readdata(<span class="number">0x000000</span>,datar,<span class="number">4</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">1</span>,datar[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">4</span>,datar[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">7</span>,datar[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">10</span>,datar[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是调用方法，可以看到数据成功被移入w25q64中，并且断电也没有丢失。</p>
<h4 id="硬件模拟spi"><a href="#硬件模拟spi" class="headerlink" title="硬件模拟spi"></a>硬件模拟spi</h4><p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/PixPin_2025-05-02_00-21-49.png" alt="PixPin_2025-05-02_00-21-49"></p>
<p>stm32的库函数已经帮我们处理好了很多细节上的配置，基本上按照流程图加结构体配置，就可以使用硬件模拟spi了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_w_ss</span><span class="params">(<span class="type">uint8_t</span> bitvalue)</span>&#123;</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)bitvalue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5| GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	SPI_InitTypeDef SPI_InitStruct;</span><br><span class="line">	SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;</span><br><span class="line">	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;</span><br><span class="line">	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;</span><br><span class="line">	SPI_InitStruct.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">	SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;</span><br><span class="line">	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;</span><br><span class="line">	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;</span><br><span class="line">	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;</span><br><span class="line">	SPI_Init(SPI1, &amp;SPI_InitStruct);</span><br><span class="line">	</span><br><span class="line">	SPI_Cmd(SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myspi_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	myspi_w_ss(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">myspi_swapbyte</span><span class="params">(<span class="type">uint8_t</span> bytesend)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != SET);</span><br><span class="line">    SPI_I2S_SendData(SPI1, bytesend);</span><br><span class="line">    <span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != SET);</span><br><span class="line">    <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是硬件模拟spi的底层代码，与其他外设大同小异，都是结构体配置还有什么状态读取之类的。</p>
<h3 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h3><p>can通信在四大通信里面算是最难的一款了通信协议了，它兼具IIC和USART通信的一些特点，一样有TX和RX两根线，没有时钟线，全双工，但是又可以一对多进行数据通信，多用于板子间的数据交流。</p>
<p>而且can通信有非常完善的数据纠错等等功能，可以很好地处理异常，错误等各种情况。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/BB395BB43C68A69FAFFD812AB538B50A.jpg" alt="BB395BB43C68A69FAFFD812AB538B50A"></p>
<p>这是CAN总线的几种帧格式，用的最多的还是数据帧和遥控帧。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/64F3FE0F7788F7928F7336A3275267F7.jpg" alt="64F3FE0F7788F7928F7336A3275267F7"></p>
<p>这是can通信的时序，分为标准格式和扩展格式两种，标准格式和扩展格式的区别是扩展格式的ID可以更长一点，扩展格式id有29位。</p>
<p>不过平常还是使用标准格式比较多，毕竟没这么多设备。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/64570E254949F2F00597014011FA048A.jpg" alt="64570E254949F2F00597014011FA048A"></p>
<p>可以对着上图的简介表理解时序图，can通信每一次发送最多可以发送8字节。</p>
<p>还有就是can通信的仲裁段，如果碰到两个设备同时准备发送通信，就会进入仲裁阶段，仲裁的依据主要就是id号的大小，id号越小的仲裁获胜的可能性越大，并且标准大于扩展，数据帧大于遥控帧，这里的位数设计非常巧妙，很好地兼容了标准格式和扩展格式两种情况。</p>
<p>下面是一些can总线为我传输不出错更严谨的独特机制。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/DA7195F27407D4D7F1D9D27E8227B05F.jpg" alt="DA7195F27407D4D7F1D9D27E8227B05F"></p>
<p>首先是位填充，为了避免发送大量相同的数据造成误判的可能情况，所以设计了位填充的机制，就是每发5个相同电平时，会自动在后面追加一个相反电平的填充位，具体机制可以看上图。</p>
<p>这个可以防止发送大量相同的电平，比如连续发送隐性1，被误判为进入了空闲状态，（连续发送11个隐性1就是进入了空闲状态，11位其实就是时序图中的ack界定符加上7的个结束位加上3个的帧间隔）</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/631928DB379DFC98E67C46FB3CA2C9BA.jpg" alt="631928DB379DFC98E67C46FB3CA2C9BA"></p>
<p>还有就是关于时序上的一些知识点，其中每一个位的采集又可以细分为4个部分，其中ss是同步段，就是每次一开始发数据，每个设备都会利用ss来进行同步，确保自己的初始时钟是正确的，这就是硬同步。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/0872D0C959DE12E5DAC9E9ED236A4335.jpg" alt="0872D0C959DE12E5DAC9E9ED236A4335"></p>
<p>pts是传播时间段，这个通常有硬件问题而配置的，毕竟传输过来还需要时间。</p>
<p>然后就是pbs1和pbs2，这两个就是控制采样位的核心了，也是再同步。</p>
<p><img src="/2024/12/07/32%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/2ED55889A566C8C77329F97A8C0A7B78.jpg" alt="2ED55889A566C8C77329F97A8C0A7B78"></p>
<p>就是通过设置sjw，sjw会在通信的过程中，保证采样点在pbs1和pbs2之间，不过这些都是硬件电路自动完成的，这就是can通信的再同步机制。</p>
<h4 id="硬件调用CAN通信"><a href="#硬件调用CAN通信" class="headerlink" title="硬件调用CAN通信"></a>硬件调用CAN通信</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;                  // Device header</span><br><span class="line">void Mycan_Init()</span><br><span class="line">&#123;	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);	</span><br><span class="line">	</span><br><span class="line">	CAN_InitTypeDef CAN_InitStruct;</span><br><span class="line">	CAN_InitStruct.CAN_ABOM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_AWUM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_BS1 = CAN_BS1_2tq;</span><br><span class="line">	CAN_InitStruct.CAN_BS2 = CAN_BS2_3tq;</span><br><span class="line">	CAN_InitStruct.CAN_Mode = CAN_Mode_LoopBack;</span><br><span class="line">	CAN_InitStruct.CAN_NART = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_Prescaler = 48;</span><br><span class="line">	CAN_InitStruct.CAN_RFLM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_SJW = CAN_SJW_2tq;</span><br><span class="line">	CAN_InitStruct.CAN_TTCM = DISABLE;</span><br><span class="line">	CAN_InitStruct.CAN_TXFP = DISABLE;</span><br><span class="line"></span><br><span class="line">	CAN_Init(CAN1,&amp;CAN_InitStruct);</span><br><span class="line">	</span><br><span class="line">	CAN_FilterInitTypeDef CAN_FilterInitStruct;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterActivation = ENABLE;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdHigh = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterIdLow = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdHigh = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMaskIdLow = 0x0000;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterMode = CAN_FilterMode_IdMask;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterNumber = 0;</span><br><span class="line">	CAN_FilterInitStruct.CAN_FilterScale = CAN_FilterScale_32bit;</span><br><span class="line">	CAN_FilterInit(&amp;CAN_FilterInitStruct);</span><br><span class="line">&#125;</span><br><span class="line">void Mycan_transmit(uint32_t id,uint8_t length,uint8_t *data)</span><br><span class="line">&#123;</span><br><span class="line">	CanTxMsg TxMessage;</span><br><span class="line">	for(uint8_t i=0;i&lt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		TxMessage.Data[i] = data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	TxMessage.DLC = length;</span><br><span class="line">	TxMessage.ExtId = id;</span><br><span class="line">	TxMessage.IDE = CAN_Id_Standard;</span><br><span class="line">	TxMessage.RTR = CAN_RTR_DATA;</span><br><span class="line">	TxMessage.StdId = id;</span><br><span class="line">	uint8_t transmitmailbox = CAN_Transmit(CAN1,&amp;TxMessage);</span><br><span class="line">	while(CAN_TransmitStatus(CAN1,transmitmailbox)!=CAN_TxStatus_Ok);</span><br><span class="line">&#125;</span><br><span class="line">uint8_t Mycan_receiveflag()</span><br><span class="line">&#123;</span><br><span class="line">	if(CAN_MessagePending(CAN1,CAN_FIFO0)&gt;0)</span><br><span class="line">		return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void Mycan_receive(uint32_t *id,uint8_t *length,uint8_t *data)</span><br><span class="line">&#123;	</span><br><span class="line">	CanRxMsg RxMessage;</span><br><span class="line">	CAN_Receive(CAN1,CAN_FIFO0,&amp;RxMessage);</span><br><span class="line">	if(RxMessage.IDE==CAN_Id_Standard)</span><br><span class="line">	&#123;</span><br><span class="line">		*id=RxMessage.StdId;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		*id=RxMessage.ExtId;</span><br><span class="line">	&#125;</span><br><span class="line">	if(RxMessage.RTR==CAN_RTR_DATA)</span><br><span class="line">	&#123;</span><br><span class="line">		*length = RxMessage.DLC;</span><br><span class="line">		for(uint8_t i=0;i&lt;*length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			data[i]=RxMessage.Data[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">//	RxMessage.FMI = ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里也只是测试了一下回环通信，测试一下软件有没有问题。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>12月札记</title>
    <url>/2024/12/08/12%E6%9C%88%E6%9C%AD%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h2><p>上完工图课，6点左右的文科楼夕阳，谷歌相机直出，一直想学lr，但是一直忘记学，哎。</p>
<p>感觉拍的还是不够真实，局部太暗了，当时我怎么调的我具体也忘了。</p>
<p><img src="/2024/12/08/12%E6%9C%88%E6%9C%AD%E8%AE%B0/CRnall_20241202_175406704.jpg" alt="CRnall_20241202_175406704"></p>
<h2 id="12-6"><a href="#12-6" class="headerlink" title="12.6"></a>12.6</h2><p>这其实应该是我的电脑一直挂在那里听歌才刷出来的吧。</p>
<p><img src="/2024/12/08/12%E6%9C%88%E6%9C%AD%E8%AE%B0/B9EC1BDC6C202DD000F69D21661E9D64.jpg" alt="B9EC1BDC6C202DD000F69D21661E9D64"></p>
<h2 id="12-8"><a href="#12-8" class="headerlink" title="12.8"></a>12.8</h2><p>星期天也要早起参加教授们的介绍项目的会。</p>
<p><img src="/2024/12/08/12%E6%9C%88%E6%9C%AD%E8%AE%B0/A1FB28BAECFE34D8F1EAF56E5FD63114.jpg" alt="A1FB28BAECFE34D8F1EAF56E5FD63114"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>札记</tag>
      </tags>
  </entry>
  <entry>
    <title>小米平板5上安装stlink驱动</title>
    <url>/2024/12/07/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5%E4%B8%8A%E5%AE%89%E8%A3%85stlink%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="小米平板5上安装stlink驱动"><a href="#小米平板5上安装stlink驱动" class="headerlink" title="小米平板5上安装stlink驱动"></a>小米平板5上安装stlink驱动</h1><p>上了大学以后，考虑到游戏本的笨重和轻薄本的价格，再加上我对这方面的刷机也非常感兴趣，索性买了台小米平板5刷机神板来体验一下。刷机过程跟着教程走的，基本没什么问题，之前学51单片机的时候，也没什么问题，可以正常使用CH340驱动，但在装stm32的stlink驱动时，就出问题了。</p>
<h2 id="stlink版本"><a href="#stlink版本" class="headerlink" title="stlink版本"></a>stlink版本</h2><p>小米平板5是arm架构的芯片，所以很多软件的安装都需要考虑版本，其他版本的虽然可以转译，但是效率比较低，肯定是原生arm软件支持性比较好。</p>
<p>但我一开始没注意到这一点，就随便选了个64位的驱动安装了，也没报错，但是却不能正常使用，还卸载不了。驱动安装不会报错，但是就是用不起，非常的离谱。</p>
<h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>后来我再在网上找了arm版本的驱动，竟然真的有大佬做了适配，但是死活装不上，因为该死的微软做了驱动程序签名验证，如果你要安装没有数字签名的驱动，必须要手动设置，但是我这个平板装的系统都是被大佬修改过的，有部分功能不支持，虽然可以安装原版的Windows，但是有一些驱动未作适配，这个表现在我通过高级启动进入疑难解答的时候，发现触屏不能使用，也不能像安卓刷机一样利用音量键和电源键控制。</p>
<p>这个签名验证的关闭失败的操作如下</p>
<p><img src="/2024/12/07/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5%E4%B8%8A%E5%AE%89%E8%A3%85stlink%E9%A9%B1%E5%8A%A8/IMG_20241205125141988.jpg" alt="IMG_20241205125141988"></p>
<p>我尝试了几个版本的Windows，懒人包刷不了就刷wim，反正驱动mindows会帮我自动打好，但是每一个包都有各种各样离奇的问题，导致关闭不了驱动验证。</p>
<h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>朋友发现了酷安的一个帖子，就是专门解决这个问题的，没想到在基安还有这么多人跟我一样，都选择用小米平板5来做嵌入式的，基本的使用都没问题，而且也很方便。</p>
<p>原理就是通过mindows的内置的工具，直接安装驱动，绕过微软的限制。操作如下，</p>
<p>先进入平板的fastboot模式，注意，这里应该不能用adb命令进入，我用adb reboot fastboot进入的是fastbootd模式，mindows也检测不出来，必须要长按电源跟音量减键进入fastboot模式，然后用mindows的脚本进入大容量模式，操作界面如图</p>
<p><img src="/2024/12/07/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5%E4%B8%8A%E5%AE%89%E8%A3%85stlink%E9%A9%B1%E5%8A%A8/2024-12-07211215.png" alt="屏幕截图 2024-12-07 211215"></p>
<p>通过fastboot临时启动进去便可以了，一路跟着提示走，不会出什么问题的。</p>
<p>然后再进入mindows的安装和删除驱动脚本，选中arm版本的stlink驱动就可以安装了，没有其他的问题。</p>
<p><img src="/2024/12/07/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5%E4%B8%8A%E5%AE%89%E8%A3%85stlink%E9%A9%B1%E5%8A%A8/2024-12-07211137.png" alt="屏幕截图 2024-12-07 211137"></p>
<p>安装完了以后就可以重启退出fastboot模式，如果你是安卓时进入的fastboot，那还要刷入uefi做启动引导，如果是在win的状态下，重启即可。重启以后，就可以发现，stlink已经装好了，如果还是提示感叹号的话，那就搜索电脑上的驱动，选择stlink安装即可。</p>
<p><img src="/2024/12/07/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF5%E4%B8%8A%E5%AE%89%E8%A3%85stlink%E9%A9%B1%E5%8A%A8/1.jpg" alt="CRnall_20241207_003004504"></p>
<p>差不多到这里就结束了，事实证明，可以在keli5里正常使用stlink进行load，做好基本库的配置后就可以痛苦地开始stm32的学习使用了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>小米平板5不愧为刷win神板，使用体验非常好，轻便，续航也是在线的，唯一有点可惜的就是充电功率差了点意思，只有33w。价格也算美丽，如果不做扩容的话，800-900就可以拿下，保值也非常保值，我做了扩容，扩容到了12+512，要15张了，其实感觉也没什么大必要。</p>
<p>至于小米平板5的刷win，市面上有非常多成熟的图文和视频教程，我也没遇到什么问题，非常的顺利，我就不打算记录了（其实是当时根本没拍照记录），某贼的mindows做的也是非常好，工具什么的都挺全的，玩机圈就是有这么些大佬支撑着，为爱发电，才发展起来的啊。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向实战——录音达人</title>
    <url>/2024/12/29/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BD%95%E9%9F%B3%E8%BE%BE%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="安卓逆向实战——录音达人"><a href="#安卓逆向实战——录音达人" class="headerlink" title="安卓逆向实战——录音达人"></a>安卓逆向实战——录音达人</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是从mt论坛的一篇教程帖子而来的，算是比较简单的入门级逆向了，但我觉得可以很好地体现逆向思路，于是便记录了下来。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先观察这个软件的会员截图</p>
<p><img src="/2024/12/29/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BD%95%E9%9F%B3%E8%BE%BE%E4%BA%BA/6553C67F466E40634ACD981A30B238A7.jpg" alt="6553C67F466E40634ACD981A30B238A7"></p>
<p>提示有VIP，而且需要登陆才可以使用。</p>
<p>然后果断放到mt里面看看情况。</p>
<p>这款软件逆向起来比较简单，没有加壳，但有签名验证。所以首先是用mt管理器对它进行去签处理，就用v1+v2+v3的版本就行了。</p>
<p><img src="/2024/12/29/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BD%95%E9%9F%B3%E8%BE%BE%E4%BA%BA/41B41AA72F1CB66E5CD92DAE30C18619.jpg" alt="41B41AA72F1CB66E5CD92DAE30C18619"></p>
<p>去签了之后就可以对dex文件进行逆向操作了。</p>
<p>这种简单的app直接搜方法名就行了。搜索isvip，进入第一个方法。</p>
<p><img src="/2024/12/29/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BD%95%E9%9F%B3%E8%BE%BE%E4%BA%BA/07AFEB63A5F7BD1E848BBD002C38A582.jpg" alt="07AFEB63A5F7BD1E848BBD002C38A582"></p>
<p>然后就开始分析smial语法就行了。我就直接把smile语法贴出来了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.method public isVip()Z</span><br><span class="line">    .registers 2		//申请寄存器，提示需要两个变量</span><br><span class="line"></span><br><span class="line">    .line 1</span><br><span class="line">    sget-object v0, Lf4/e$b;-&gt;a:Lf4/e;</span><br><span class="line"></span><br><span class="line">    .line 2</span><br><span class="line">    invoke-virtual &#123;v0&#125;, Lf4/e;-&gt;d()Z		//传递进v0变量到d函数中，并且返回一个布尔变量</span><br><span class="line"></span><br><span class="line">    move-result v0			//将上一步返回的变量储存到v0中</span><br><span class="line"></span><br><span class="line">    const/4 v0, 0x1			//逆向代码，这是我编辑上去的</span><br><span class="line"></span><br><span class="line">    return v0		//结束方法，返回v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>



<p>分析可知，这是一个判断是否为vip的方法，就是通过d函数的返回值来判断是否为vip，这里mt论坛上的原帖是再次进入d函数中，针对d函数所返回的值进行逆向，也是可行的，我就直接在下面加了一行代码，将v0强行赋值为1，一样可以实现逆向。</p>
<p>效果如下，可以看到已经成为VIP了。</p>
<p><img src="/2024/12/29/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BD%95%E9%9F%B3%E8%BE%BE%E4%BA%BA/7ECCE2F26292E5245074751E230D3106.jpg" alt="7ECCE2F26292E5245074751E230D3106"></p>
<p>然后就是关于文字转语音的时长破解。</p>
<p>在isvip的方法往上翻，可以找到这个方法getUserTimeS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.method public getUserTimeS()J</span><br><span class="line">    .registers 3</span><br><span class="line"></span><br><span class="line">    .line 1</span><br><span class="line">    sget-object v0, Lj4/l$c;-&gt;a:Lj4/l;</span><br><span class="line"></span><br><span class="line">    .line 2</span><br><span class="line">    invoke-virtual &#123;v0&#125;, Lj4/l;-&gt;d()J</span><br><span class="line"></span><br><span class="line">    move-result-wide v0</span><br><span class="line"></span><br><span class="line">    return-wide v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>



<p>这个就是控制可语音转文字时长的关键代码。修改原理跟上面的类似，也是直接在返回v0的值前给v0赋值。</p>
<p>这里我用的论坛给的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const-wide v0, 0x4102369980000L</span><br></pre></td></tr></table></figure>

<p>这样对v0进行赋值就可以了。</p>
<p><img src="/2024/12/29/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BD%95%E9%9F%B3%E8%BE%BE%E4%BA%BA/34919DE19662CA990A24BEF675F28A3E.jpg" alt="34919DE19662CA990A24BEF675F28A3E"></p>
<p>逆向成功，可以正常使用语音转文字功能。帖子里的逆向方法是继续进入d函数里面，对d函数的返回值进行修改，大同小异，也可以最终实现功能</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>至此，所有的逆向已经结束。附上原帖：<a href="https://bbs.binmt.cc/thread-142642-1-1.html">https://bbs.binmt.cc/thread-142642-1-1.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>逆向 安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>一个基于python的简单b站收藏记录程序</title>
    <url>/2025/01/04/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E7%AE%80%E5%8D%95b%E7%AB%99%E6%94%B6%E8%97%8F%E8%AE%B0%E5%BD%95%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="一个基于python的简单b站收藏记录程序"><a href="#一个基于python的简单b站收藏记录程序" class="headerlink" title="一个基于python的简单b站收藏记录程序"></a>一个基于python的简单b站收藏记录程序</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>做这个程序的初衷是因为被b站官方的视频记录恶心到了，很多时候不知道为什么，打开那种合集视频，每次都不能成功定位到我上一次看视频的位置，每次都是从第一个视频开始看，然后还要一个个地翻找才可以回到那个具体的视频。于是我就想做一个简单的程序，通过输入b站视频的地址，就可以自动转换为超链接并且保存到md文件中，方便以后的浏览。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这个程序就是输入你所看的b站视频链接，推荐输入精准空降的那个链接，可以更加方便的定位，便于下一次浏览，当然普通的链接一样可行。</p>
<p>接受到链接后，就通过爬虫，爬取到这个视频的标题，并且做成超链接，写入到同一目录下的收藏.md文件中，如果没有这个文件，也会自动创建这个文件。</p>
<p>如果连续输入两次相同的链接，会将新的链接替换到老的链接上，而不会继续添加新的超链接，避免了数据的冗杂。</p>
<p>在每次输入完链接，并执行完主程序后，会提示用户，是否继续操作，如果用户想继续添加链接，根据提示输入相应的指令就可以了。</p>
<p>一个很简单的小程序，将近100行代码就可以完成的，核心就是正则和文件的读取操作。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>开源在了GitHub上：<a href="https://github.com/luckylca/bil_record/tree/lca">https://github.com/luckylca/bil_record/tree/lca</a></p>
<p>想使用的话直接进releases里下载exe就行。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>模仿QQNT的html界面</title>
    <url>/2025/01/18/%E6%A8%A1%E4%BB%BFQQNT%E7%9A%84html%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="模仿QQNT的html界面"><a href="#模仿QQNT的html界面" class="headerlink" title="模仿QQNT的html界面"></a>模仿QQNT的html界面</h1><p>简单的看了一会html跟css一些基本知识，再看了会基本的js内容和vue框架的基本知识，花了两天的时间浅写了一个模仿QQNT登录界面的网页源码。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>1.通过网上的头像获取接口，实现用户输入QQ号时，实时展现头像。</p>
<p>2.界面大致模仿QQNT的登陆界面，一些小功能比如超链接跳转也有。</p>
<p>3.可以对输进去的密码进行前端验证，要求是6-18位并且必须同时包括字母和数字。</p>
<p>4.只有当QQ号和密码同时写进去的时候，登录按钮才会变亮，与实际QQNT操作相同。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;interface&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;exit&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;exit&quot;</span>&gt;</span> x<span class="tag">&lt;/<span class="name">div</span>&gt;</span>        </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circlr&quot;</span> <span class="attr">id</span>=<span class="string">&quot;circlr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;qq&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">inputmode</span>=<span class="string">&quot;numeric&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;                    输入QQ号&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;validateInput&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;pw&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;                   输入QQ密码&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;agreement&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;sta&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>已阅读并同意<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://bkimg.cdn.bcebos.com/pic/d4628535e5dde711b23510aea6efce1b9c166186?x-bce-process=image/format,f_jpg&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>服务协议<span class="tag">&lt;/<span class="name">a</span>&gt;</span>和<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://rule.tencent.com/rule/3fd52bde-6555-453b-9ab8-c5f1f3d22c62&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>QQ隐私保护指引<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;submit_button1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit_button1&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这是html部分。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.interface</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">315px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">182</span>,<span class="number">193</span>,<span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">173</span>,<span class="number">216</span>,<span class="number">230</span>,<span class="number">0.5</span>)); <span class="comment">/* 淡粉色和淡蓝色渐变 */</span></span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">        <span class="attribute">animation</span>: colorShift <span class="number">10s</span> infinite ease-in-out; <span class="comment">/* 使用ease-in-out平滑过渡 */</span></span><br><span class="line">        <span class="attribute">margin</span>: auto;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">90px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">@keyframes</span> colorShift &#123;</span><br><span class="line">        <span class="number">0%</span> &#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">182</span>,<span class="number">193</span>,<span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">173</span>,<span class="number">216</span>,<span class="number">230</span>,<span class="number">0.5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">25%</span> &#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, <span class="built_in">rgba</span>(<span class="number">173</span>,<span class="number">216</span>,<span class="number">230</span>,<span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">182</span>,<span class="number">193</span>,<span class="number">0.5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">50%</span> &#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">182</span>,<span class="number">193</span>,<span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">173</span>,<span class="number">216</span>,<span class="number">230</span>,<span class="number">0.5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">75%</span> &#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, <span class="built_in">rgba</span>(<span class="number">173</span>,<span class="number">216</span>,<span class="number">230</span>,<span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">182</span>,<span class="number">193</span>,<span class="number">0.5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">100%</span> &#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">182</span>,<span class="number">193</span>,<span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">173</span>,<span class="number">216</span>,<span class="number">230</span>,<span class="number">0.5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="selector-id">#username</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">36px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">31px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#password</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">36px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">31px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.agreement</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">31px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.agreement</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#007BFF</span>; <span class="comment">/* 超链接的颜色 */</span></span><br><span class="line">    <span class="attribute">text-decoration</span>: none; <span class="comment">/* 去掉下划线 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.submit_button1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">31px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#007BFF</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circlr</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">50%</span>; <span class="comment">/* 创建圆形 */</span></span><br><span class="line">        <span class="attribute">background-size</span>: cover; <span class="comment">/* 确保图片覆盖整个圆形 */</span></span><br><span class="line">        <span class="attribute">background-position</span>: center; <span class="comment">/* 图片居中 */</span></span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 更大的字体 */</span></span><br><span class="line">        <span class="attribute">font-weight</span>: normal; <span class="comment">/* 更宽的字体 */</span></span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#999</span>; <span class="comment">/* 占位符文字颜色 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="selector-class">.exit</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>这是css部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">link1</span>: <span class="string">&quot;https://q4.qlogo.cn/g?b=qq&amp;nk=&quot;</span>,</span><br><span class="line">      <span class="attr">link2</span>: <span class="string">&quot;&amp;s=100&quot;</span>,</span><br><span class="line">      <span class="attr">linktest</span>: <span class="string">&quot;https://q4.qlogo.cn/g?b=qq&amp;nk=2777581179&amp;s=100&quot;</span>,</span><br><span class="line">      <span class="attr">qq</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">link_full</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">qq1</span>: <span class="string">&quot;2777581179&quot;</span>,</span><br><span class="line">      <span class="attr">pw1</span>: <span class="string">&quot;abc123456&quot;</span>,</span><br><span class="line">      <span class="attr">pw</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">sta</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">qq</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">link_full</span> = <span class="variable language_">this</span>.<span class="property">link1</span> + <span class="variable language_">this</span>.<span class="property">qq</span> + <span class="variable language_">this</span>.<span class="property">link2</span>;</span><br><span class="line">      <span class="keyword">const</span> circleElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;circlr&#x27;</span>);</span><br><span class="line">      circleElement.<span class="property">style</span>.<span class="property">backgroundImage</span> = <span class="string">`url(<span class="subst">$&#123;<span class="variable language_">this</span>.link_full&#125;</span>)`</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">qq</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">pw</span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;submit_button1&#x27;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;submit_button1&#x27;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="number">0.1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">pw</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">qq</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">pw</span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;submit_button1&#x27;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;submit_button1&#x27;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="number">0.1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">validateInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">qq</span> = <span class="variable language_">this</span>.<span class="property">qq</span>.<span class="title function_">replace</span>(<span class="regexp">/\D/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="title function_">containsLetter</span>(<span class="params">str</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/[a-zA-Z]/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="title function_">containsDigit</span>(<span class="params">str</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/\d/</span>.<span class="title function_">test</span>(str);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">exit</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">close</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">submit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">sta</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;请同意服务协议和隐私保护指引&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>((<span class="variable language_">this</span>.<span class="property">pw</span>.<span class="property">length</span> &lt; <span class="number">8</span> || <span class="variable language_">this</span>.<span class="property">qq</span>.<span class="property">length</span> &gt; <span class="number">16</span>) || !<span class="variable language_">this</span>.<span class="title function_">containsLetter</span>(<span class="variable language_">this</span>.<span class="property">pw</span>) || !<span class="variable language_">this</span>.<span class="title function_">containsDigit</span>(<span class="variable language_">this</span>.<span class="property">pw</span>))&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;密码长度为8-16个位且需要包含字母和数字&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">qq</span> == <span class="variable language_">this</span>.<span class="property">qq1</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">pw</span> == <span class="variable language_">this</span>.<span class="property">pw1</span>)&#123;</span><br><span class="line">          <span class="title function_">alert</span>(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="title function_">alert</span>(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是js部分。</p>
<p>实现效果我部署到GitHub pages上了：<a href="https://luckylca.github.io/html_practice/">https://luckylca.github.io/html_practice/</a></p>
<h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><p>不得不说，这个vue框架对于写交互真的方便太多了，就是实际deploy有点难，有的时候build出来的html在本地打不开，单纯的上传到GitHub上用pages也实现不了，好在官方给了文档里面，写了如何部署在GitHub pages上。就这个部署折腾了我半天</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>长理教务查成绩</title>
    <url>/2025/01/28/%E9%95%BF%E7%90%86%E6%95%99%E5%8A%A1%E6%9F%A5%E6%88%90%E7%BB%A9/</url>
    <content><![CDATA[<h1 id="长理教务查成绩"><a href="#长理教务查成绩" class="headerlink" title="长理教务查成绩"></a>长理教务查成绩</h1><p>闲来无事，尝试搞了个长理教务查成绩的脚本，非常简陋，就直接爬取到了长理教务的成绩单直接展示出来了，没有对数据进行清洗什么的，因为本身还是能看的过去。</p>
<p><img src="/2025/01/28/%E9%95%BF%E7%90%86%E6%95%99%E5%8A%A1%E6%9F%A5%E6%88%90%E7%BB%A9/Snipaste_2025-01-28_14-19-56.jpg" alt="Snipaste_2025-01-28_14-19-56"></p>
<p>具体效果如上，懒得在正则重新写ui了。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="获取表单"><a href="#获取表单" class="headerlink" title="获取表单"></a>获取表单</h3><p>通过浏览器的开发者工具进行分析，发现了获得成绩单的关键请求，就是请求网址<a href="http://xk.csust.edu.cn/jsxsd/kscj/cjcx_list">http://xk.csust.edu.cn/jsxsd/kscj/cjcx_list</a> 是这个的包，它会返回一段html内容，html内容就是成绩单的解析，其实这也就是我最终程序呈现出来的成绩，于是，我就先花了一点时间，做了个通过接受用户输入cookie，定制一个请求的脚本，发现只要输入正确的cookie，然后按照其他请求的格式设置header以后，就可以获得正确的成绩单，非常的简单。</p>
<p><img src="/2025/01/28/%E9%95%BF%E7%90%86%E6%95%99%E5%8A%A1%E6%9F%A5%E6%88%90%E7%BB%A9/Snipaste_2025-01-28_16-05-31.jpg" alt="Snipaste_2025-01-28_16-05-31"></p>
<p>这个程序效果如上，只要对应的cookie是正确的，就可以正常获取到我们想要的内容了。</p>
<h2 id="获得cookie"><a href="#获得cookie" class="headerlink" title="获得cookie"></a>获得cookie</h2><p>这就让我头疼了很久，因为长理的教务真的很烂，让我很困惑，有的时候我明明清空了长理教务的所有cookie的时候，重新加载，发的包仍然会带一个cookie，可能是浏览器的原因吧，但是我多尝试了一下，也发现了规律。</p>
<ol>
<li><p>通过之前的那个通过cookie获取成绩单的脚本可以知道，cookie需要三个值，其中两个的名字是JSESSIONID，还有一个的名字是 SERVERID_jsxsd，这个SERVERID_jsxsd的值是定值，一直是njxpc133这个字符串，而那两个JSESSIONID则是不一样的值。</p>
</li>
<li><p>每次我们用浏览器访问首页的时候，它都会给我们返回两个cookie，一个是JSESSIONID，一个是SERVERID_jsxsd，然后在我们输入完账号密码后点击登录的时候，会把我们的账号密码通过base64加密，然后再带上前面的两个cookie发送到<a href="http://xk.csust.edu.cn/jsxsd/xk/LoginToXk">http://xk.csust.edu.cn/jsxsd/xk/LoginToXk</a> 这个网址，如果检验正确就会返回一个名字也是JSESSIONID的cookie，并且重定向到我们的主页。</p>
</li>
</ol>
<p><img src="/2025/01/28/%E9%95%BF%E7%90%86%E6%95%99%E5%8A%A1%E6%9F%A5%E6%88%90%E7%BB%A9/Snipaste_2025-01-28_16-20-48.jpg" alt="Snipaste_2025-01-28_16-20-48"></p>
<p>就是这个包。</p>
<p>这下子思路就清晰多了，就是先访问首页获取两个cookie，然后再构造一个带有我们加密后的密码的包，获取第三个cookie，把这三个cookie合在一起用在获取成绩单上，就可以顺利拿到成绩单了。</p>
<p>总体来说挺简单的，霓裳没加反爬虫之类的，这弄的我真想拿一些扫洞脚本给这教务跑一跑了。</p>
<h2 id="一点曲折"><a href="#一点曲折" class="headerlink" title="一点曲折"></a>一点曲折</h2><p>当我在获得前两个cookie后，转而思考第三个cookie获取的时候，被卡了很久，因为不知道为什么，我按照格式一模一样构造请求包，返回的一直是200，而不是302重定向，也一直没拿到正确的cookie，后来研究了很久才发现，我的这个请求的载荷中有**%%%<strong>这个作为分割账号和密码，但是我一开始的载荷设置是根据浏览器里的源代码，它是</strong>%25%25%25**的，所以才导致我一直请求失败，估计是判断账号密码错误，给我跳回登陆界面了。</p>
<p>还有就是一直没搞明白霓裳这b教务具体是怎么搞的，测试了好多次都有几次过程和之前不同，要么就是post载荷又变了，要么就老是404，但是我目前这个方法，还是可以用的。</p>
<p>这是GitHub项目地址：<a href="https://github.com/luckylca/csust_scorecheck">长理教务查成绩</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>科目一学习app</title>
    <url>/2025/03/01/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%AD%A6%E4%B9%A0app/</url>
    <content><![CDATA[<h1 id="科目一学习app"><a href="#科目一学习app" class="headerlink" title="科目一学习app"></a>科目一学习app</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在网上找了个接口，关于科目一习题的接口，也刚好在学前端，就花了点时间，写了个小的uniapp项目，就是一个科目一做题的简单app。</p>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>做了三个功能，一个每日练习，一个全真模拟，一个错题集。</p>
<p>界面如下：</p>
<p><img src="/2025/03/01/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%AD%A6%E4%B9%A0app/Snipaste_2025-03-04_18-19-46.jpg" alt="Snipaste_2025-03-04_18-19-46"></p>
<p>主要还是不太会ui设计，想做出高级感，也只会加点阴影了。</p>
<p>具体代码开源到GitHub上了。<a href="https://github.com/luckylca/kemu1_learn">科目一练习</a></p>
<p>这个原本还可以有H5版本的，但是因为只是拿的别人的接口，处理不了浏览器跨域问题，如果本地调试还可以设置本地代理绕过，但是发布成网页界面，就不能拿到正确资源了。所以我只打包成了app端。</p>
<p>在我一开始打包的时候，发现安卓和小程序端的一些界面一直进不去，但是web端就是正常的，经过排查发现，是因为我做了动画，就是当点击按钮的时候，通过盒子的id获取到dom，然后再给这个dom添加动画css来实现按键动画的功能，后来发现小程序和app端都不支持这个获取id的代码，因为这个方法是原生webjs的功能。</p>
<p>后来在我咨询了ai，以后，发现可以用另一种方式实现功能，就是通过:class的方法，通过操控响应式变量来控制class是否应用，比较方便，也可以兼容多端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个很简单的前端练手项目而已，ui也写的不是很好，部分css还是咨询了ai，比如设置背景颜色渐变什么的，还有部分动画也是。</p>
<p>不过最后写出来的app还是很能用的，有错题的功能，我查过了，题库总共大概有4000道题，每道题都有对应的解析。</p>
<p>也有美中不足的问题，就是我的项目不支持多选，有些题目是多选题，但是我的项目只能选一个提交，不过目前暂时没有改进的想法</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS学习</title>
    <url>/2025/06/17/FreeRTOS%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="FreeRTOS学习"><a href="#FreeRTOS学习" class="headerlink" title="FreeRTOS学习"></a>FreeRTOS学习</h1><p>在学完初步的stm32后，便开始了解到了FreeRTOS这个实时操作系统，可以很轻松的实现多任务管理，既可以同时运行多个while1的任务，不会有阻塞的情况。</p>
<p>本质上就是切换任务并且保存寄存器的值到栈里面，即保存现场，当切换回来的时候，又从栈里面将寄存器的值恢复回去。</p>
<p>我使用的是STMcubemx库生成的FreeRTOS的方式，简单易用，只需要开启FreeRTOS支持和简单创建几个任务，然后修改任务的运行函数就可以了，通过osDelay来控制运行时间。</p>
<p>首先是基础理论学习：</p>
<h2 id="ARM架构基础知识"><a href="#ARM架构基础知识" class="headerlink" title="ARM架构基础知识"></a>ARM架构基础知识</h2><h3 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h3><p>ARM芯片属于精简指令集计算机，有CPU，Flash，内存，其中Flash就相当于硬盘，读取写入速度最快，内存则比Flash快不少，最快的是CPU里面的寄存器，读写速度是纳秒级别，可以跟的上CPU的运行速度。</p>
<p>但是CPU的内部寄存器资源很有限，所以程序通常只会放一部分需要交给CPU运算的变量到寄存器里面，就是寄存器读内存的值，其他的基本都是放在内存里面，而Flash则是保存整个程序的。</p>
<p>寄存器一般的寄存器是r0，r1这样的，还有一些特殊的寄存器，其中有SP，LR，PC，SP一般是保存栈指针，LR则是一般用来保存返回地址，就是跳转到其他函数的时候，将需要跳转回去的函数地址写进去，而PC则是程序计数器，表示的是当前指令地址，写入新值就可以跳转。</p>
<h3 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h3><p>读内存 Load</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0,[R1,#4]	//读地址“R1+4”，得到的四个字节存入R0</span><br></pre></td></tr></table></figure>

<p>写内存 Store</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR R0,[R1,#4]	//把R0的4字节数据写入地址“R1+4”</span><br></pre></td></tr></table></figure>

<p>加减</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD R0,R1,R2	//R0 = R1+R2</span><br><span class="line">SUB R0,R1,R2	//R0 = R1-R2</span><br></pre></td></tr></table></figure>

<p>比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMP R0，R1	//将比较结果保存在程序状态寄存器PSR</span><br></pre></td></tr></table></figure>

<p>跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B main	//直接跳转，PC写入main函数地址</span><br><span class="line">BL main	//先保存返回地址到LR</span><br></pre></td></tr></table></figure>



<p>在运行函数的时候，会先将所需要的内容，比如局部变量什么的，保存在栈里面，还有将LR也保存进去，然后CPU使用LDRD进行读取，将需要的东西读取到寄存器里面，然后再进行运算，运算完成以后，通过STR修改栈里面的数据，就是将CPU运算出来的结果再返回的栈里面，将栈里面的数据一起POP给CPU寄存器，同时也将之前保存的LR的地址POP给PC，这就完成一个运行一个自定义函数的过程。</p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>堆就是一块空闲的内存，可以使用但是要记得释放。</p>
<p>一般实际使用堆分配内存即进行堆管理的时候，通常会带一个头部和后面的内存，头部通常储存了将会分配多少内存，在有了头部之后，我们接下来就可以很好地完成释放内存的的操作了，因为头部储存了内存大小，我们就知道了需要释放了多少内存，但是问题又来了，这样一直使用，不断分配释放内存，会发现有很多空的内存，我们应该怎么使用它空的内存呢，这里就就需要引入链表了。就是在头部中再加一个nextFree，指向下一个空闲的内存的地址，就是通过链表储存空闲内存，当我们在分配内存的时候，就会修改头部的nextFree所指向的地址，将这个地址指向新的空闲内存。</p>
<p>栈就是程序自己分配的一块区域，每个任务都有自己的一个栈，专门用来储存一个函数运行过程中的一些中间变量，比如储存不同的LR，还有过程中的不同的中间变量，在RTOS中还可以保存现场，将寄存器中的所有的值都存入栈里面。</p>
<p>其中，如果局部变量比较少或者不加volatile的情况下，这些局部变量都会保存在寄存器里面，这是因为编译的时候进行了优化，放到寄存器里面可以提高速度，但是如果局部变量比较多，或者加上了volatile，编译器就不会对它进行优化，就会将它直接保存到栈里面。</p>
<h2 id="FreeRTOS编程规范"><a href="#FreeRTOS编程规范" class="headerlink" title="FreeRTOS编程规范"></a>FreeRTOS编程规范</h2><p>FreeRTOS中对函数和变量的命名都很有规范，通常会在一个变量的前面加入一些前缀，来表示这个变量的属性，更加简单易读。</p>
<p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/DShanMCU-F103/chapter-7/image5.jpg"></p>
<p>这是对里面函数命名的规范。</p>
<p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/DShanMCU-F103/chapter-7/image6.jpg"></p>
<p>这是对里面宏的命名规范。</p>
<p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/DShanMCU-F103/chapter-7/image7.jpg"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>我们通常使用的就是heap4的堆管理方法，heap4可以很好地解决碎片化的问题，相邻空闲内存可以合并。</p>
<p>常见的内存管理里面的函数有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void * pvPortMalloc( size_t xWantedSize );</span><br><span class="line">void vPortFree( void * pv );</span><br></pre></td></tr></table></figure>

<p>这个就是释放和分配内存的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size_t xPortGetFreeHeapSize( void );</span><br></pre></td></tr></table></figure>

<p>这个函数的返回值就是当前堆中可用的剩余内存大小，这是给开发者用来优化内存分配策略用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void * pvPortMalloc( size_t xWantedSize )vPortDefineHeapRegions</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )</span><br><span class="line">        &#123;</span><br><span class="line">            if( pvReturn == NULL )</span><br><span class="line">            &#123;</span><br><span class="line">                extern void vApplicationMallocFailedHook( void );</span><br><span class="line">                vApplicationMallocFailedHook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    return pvReturn;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是钩子函数的使用范例，如果当运行分配内存失败了，并且钩子函数的宏定义是1，就会执行<strong>vApplicationMallocFailedHook</strong>这个函数，这个函数我们需要手动定义并且写内容</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>任务最核心的三要素：函数，栈，优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数</span><br><span class="line">    const char * const pcName, // 任务的名字</span><br><span class="line">    const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节</span><br><span class="line">    void * const pvParameters, // 调用任务函数时传入的参数</span><br><span class="line">    UBaseType_t  ,    // 优先级</span><br><span class="line">    TaskHandle_t * const pxCreatedTask // 任务句柄, 以后使用它来操作这个任务</span><br><span class="line">); </span><br></pre></td></tr></table></figure>



<p>这是动态分配内存的方式创建任务，按照注释传递参数就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TaskHandle_t xTaskCreateStatic ( </span><br><span class="line">    TaskFunction_t pxTaskCode,   // 函数指针, 任务函数</span><br><span class="line">    const char * const pcName,   // 任务的名字</span><br><span class="line">    const uint32_t ulStackDepth, // 栈大小,单位为word,10表示40字节</span><br><span class="line">    void * const pvParameters,   // 调用任务函数时传入的参数</span><br><span class="line">    UBaseType_t uxPriority,      // 优先级</span><br><span class="line">    StackType_t * const puxStackBuffer, // 静态分配的栈，就是一个buffer</span><br><span class="line">    StaticTask_t * const pxTaskBuffer // 静态分配的任务结构体的指针，用它来操作这个任务</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>这是静态分配内存的方式创建任务，其实使用也不难，只需要提前声明一个合适大小的数组作为栈，另外还需要提供一个TCB结构体，使用StaticTask_t声明一个就可以了，记得使用static，其他的使用跟动态分配没有什么大差别。其中创建静态任务返回的数据是任务句柄，而创建动态任务需要自己传进去任务句柄。</p>
<h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vTaskDelete( TaskHandle_t xTaskToDelete );</span><br></pre></td></tr></table></figure>



<p>传入的参数是任务句柄，也可以传入NULL，传入NULL就是自杀。</p>
<p>不过一般都是任务自己停止，而不是调用删除任务来暂停函数的执行。</p>
<p>如果想要优化一些任务，比如说优化音乐播放这种类似的场景，可以适当提高任务优先级，在FreeRTOS中，数字越大的优先级越高，并且使用软延时vTaskDelay而非硬延时。</p>
<h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>FreeRTOS中有四个任务，分别是Ready，Running，Blocked，Suspended。</p>
<p><img src="https://rtos.100ask.net/assets/image5-44e16105.png"></p>
<p>这是一个完整的任务状态转换图。</p>
<p>一个任务被创建出来就在ready状态，这个时候随时都可以成为running状态。如果在一个任务里面有一些软延时vTaskDelay类似的函数，这个任务就会被切换成blocked状态，也就是阻塞态，等到触发到某个事件的时候，比如延时结束了，就又会回到ready状态。</p>
<p>暂停状态只能通过调用暂停状态函数才可以进入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vTaskSuspend(TaskHandle_t xTaskToSuspend);</span><br><span class="line">//进入暂停状态</span><br><span class="line">vTaskResume(TaskHandle_t xTaskToResume);</span><br><span class="line">//进入ready状态</span><br></pre></td></tr></table></figure>



<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ol>
<li>相同优先级的任务轮流运行</li>
<li>最高优先级的任务先运行，一旦高优先级的任务就绪，就会马上运行，高优先级的任务没有运行完，不会执行低优先级任务</li>
</ol>
<p>任务调度方面通过链表来进行管理。</p>
<p>都是ready的任务都是通过数组储存，比如最大的优先级是56，那么就会有一个readyList[56]的数组，里面的每一项都是一个链表，其中这个数组的索引值则代表一个优先级，同一个优先级的所有任务的TCB都是通过双向循环链表连接在一起的，一开始我们创建任务，从task0一直创建到task3，其中有一个全局变量加pxCurrentTCB，它会指向我们正在创建的任务，所以任务创建完成以后，调度开始，默认会从我们最后创建的任务开始执行。</p>
<p>FreeRTOS还会初始化一个tick中断，可以设置每1ms触发一次中断，中断就会发起一次调度，发起调度。</p>
<p>调度，先是从delayList里面遍历一边，看有没有可以被拿出来放入readyList的，如果没有，就从高到低遍历readyList里面的所有优先级，找到第一个非空的链表后，就会开始找pxCurrentTCB的位置，在pxCurrentTCB的位置的下一个TCB开始运行。</p>
<p>当任务在阻塞状态时，就会移出readyList，并且放入delayList，这个时候也会立马触发调度，重新寻找最高优先级的任务，并且从原来执行的任务的下一个TCB开始，继续运行任务。</p>
<p>所有的任务必须是死循环，不能返回出来，一旦返回出来了，就会自动跳转到prvTaskExitError函数，终止所有调度。</p>
<p>如果你打算设置你的任务只执行一会，就打算退出来了，就必须删除任务，删除任务有自杀和他杀，其中自杀就是由空闲任务进行释放TCB和释放栈，空闲任务的优先级是0，一开始调度就会创建这个空闲任务，且永远处于ready或者running状态。但是因为这个空闲任务的优先级是0，有的时候根本没有机会执行空闲任务回收内存，有可能会导致内存不够用。</p>
<p>所以我们应该使用vTaskDelay函数进行延时，让空闲函数有机会回收任务自杀的内存，</p>
<h3 id="两个delay函数"><a href="#两个delay函数" class="headerlink" title="两个delay函数"></a>两个delay函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void vTaskDelay( const TickType_t xTicksToDelay ); </span><br><span class="line">BaseType_t vTaskDelayUntil( TickType_t * const pxPreviousWakeTime,const TickType_t xTimeIncrement );</span><br></pre></td></tr></table></figure>



<p>第一个延时函数<strong>vTaskDelay</strong>是延时固定时间的函数，只能往后延时多少tick，第二个延时函数<strong>xTaskDelayUntil</strong>则是可以控制每次循环的周期相等。</p>
<p>其中<strong>xTaskDelayUntil</strong>的两个参数，第一个参数pxPreviousWakeTime，这个是起始时间，每次使用前都需要先获得一个起始时间，第二个参数xTimeIncrement是增加的时间，就是你打算让这个循环总共多少时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BaseType_t preTime;</span><br><span class="line">uint64_t t1, t2;</span><br><span class="line">preTime = xTaskGetTickCount();</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">	//循环的代码</span><br><span class="line">    vTaskDelayUntil(&amp;preTime, 500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子设置就是循环的周期固定为500tick了。</p>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列的本质就是环形缓冲区，不是有读指针和写指针的缓冲区，而是用一个数据个数来管理队列。</p>
<p>队列里面肯定有一个环形缓冲区，还有两个链表recvList和sendList，存储队列两边的任务指针，供队列两边的任务互相通信。当一个任务A在队列里写了数据，想把在阻塞态等待队列的任务B唤醒的时候，就把任务B从recvList删除，并且把它放在readyList里面。</p>
<p>先来看一些基本函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );//这是动态创建函数</span><br><span class="line">QueueHandle_t xQueueCreateStatic(*</span><br><span class="line">              		UBaseType_t uxQueueLength,*</span><br><span class="line">              		UBaseType_t uxItemSize,*</span><br><span class="line">              		uint8_t *pucQueueStorageBuffer,*</span><br><span class="line">              		StaticQueue_t *pxQueueBuffer*</span><br><span class="line">           		 );//这是静态创建函数</span><br><span class="line">BaseType_t xQueueReset( QueueHandle_t pxQueue);//复位函数</span><br><span class="line">void vQueueDelete( QueueHandle_t xQueue );//删除函数</span><br><span class="line">//下面都是写队列函数</span><br><span class="line">/* 等同于xQueueSendToBack</span><br><span class="line"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="line"> */</span><br><span class="line">BaseType_t xQueueSend(</span><br><span class="line">                                QueueHandle_t    xQueue,</span><br><span class="line">                                const void       *pvItemToQueue,</span><br><span class="line">                                TickType_t       xTicksToWait</span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="line"> */</span><br><span class="line">BaseType_t xQueueSendToBack(</span><br><span class="line">                                QueueHandle_t    xQueue,</span><br><span class="line">                                const void       *pvItemToQueue,</span><br><span class="line">                                TickType_t       xTicksToWait</span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span><br><span class="line"> */</span><br><span class="line">BaseType_t xQueueSendToBackFromISR(</span><br><span class="line">                                      QueueHandle_t xQueue,</span><br><span class="line">                                      const void *pvItemToQueue,</span><br><span class="line">                                      BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="line">                                   );</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="line"> */</span><br><span class="line">BaseType_t xQueueSendToFront(</span><br><span class="line">                                QueueHandle_t    xQueue,</span><br><span class="line">                                const void       *pvItemToQueue,</span><br><span class="line">                                TickType_t       xTicksToWait</span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span><br><span class="line"> */</span><br><span class="line">BaseType_t xQueueSendToFrontFromISR(</span><br><span class="line">                                      QueueHandle_t xQueue,</span><br><span class="line">                                      const void *pvItemToQueue,</span><br><span class="line">                                      BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="line">                                   );</span><br><span class="line">BaseType_t xQueueReceive( QueueHandle_t xQueue,</span><br><span class="line">                          void * const pvBuffer,</span><br><span class="line">                          TickType_t xTicksToWait );//读队列函数</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>一加13从购买到毕业</title>
    <url>/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="一加13从购买到毕业"><a href="#一加13从购买到毕业" class="headerlink" title="一加13从购买到毕业"></a>一加13从购买到毕业</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>我因为实在受不了澎湃系统的种种诟病和显而易见的负优化，打算换到绿厂系列体会一下友商的手机系统，并且有强烈地刷机玩机想法，小米澎湃目前的解bootloader的政策已经基本宣告曾经那个发烧友小米已死了，雷军还是继续当他的资本家去了，全然不顾之前对发烧友们的承诺。</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/PixPin_2025-07-21_22-33-54.png" alt="讽刺意义拉满"></p>
<p>从大概今年5月份左右开始，酷安包括各大手机论坛上，已经没有任何人可以通过小米答题拿到解锁权，我记的从6月份开始，小米就已经开始控分了，没有任何人可以达到90分及以上，不管怎么试探答案，所有人的成绩都是80分封顶，非常恶心，我也挺后悔的，在我决定通过小米高考给我的K70Pro解锁之前几次考试，成功率都挺高的，也有不少上岸的，但是在我开始考试的后面，只有第一次有成功案例，也不多，那一期整个酷安好像就只有个位数的有90分，然后真正拿到解锁权限的好像不超过5个，之后就再也没有成功的案例了，再之后就是控分，不管怎么写题目都是70分送上。</p>
<p>碰到这么恶心的解锁政策加史一般的澎湃OS，干脆直接投入一加的怀抱，一加13在国补的优惠下，我买了16+512的版本，3500左右拿下，只是很可惜，要是在618的话还可以省500，一加的手机也是跳水大王，首发的永远是在价格上亏爆的，但是毕竟早买早享受，晚买享优惠嘛。</p>
<p>一加13也是出名的水桶机，各个方面都不错，算是中端旗舰了，但是我实际感觉只能说中规中矩吧，也没有很让我惊艳，具体再下文细说。</p>
<h2 id="到货-体验"><a href="#到货-体验" class="headerlink" title="到货+体验"></a>到货+体验</h2><p>我虽然是在PDD上的百亿补贴买的，但是感觉体验非常好，快递顺丰次日达，这我也是真没想到，第一天中下午下单的，第二天下午就到了，就花了一天的时间吧，上完班就匆匆赶回来，到顺丰驿站拆封手机。</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250721224343_196.jpg" alt="微信图片_20250721224343_196"></p>
<p>这是用我的红米手机拍的照，不知道为什么，当时对焦对了半天都没成功，所以看上去感觉有点模糊，一加加上哈苏，我也是用上了影像准旗舰的手机，（虽然我对拍照的需求不大。</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250721224346_197.jpg" alt="微信图片_20250721224346_197"></p>
<p>这是它的第一次开机，一加加安卓，可惜这个画面以后看不到几次了，因为我到宿舍就直接下好了ROM和大侠阿木的解锁工具箱，到手就先解bootloader锁了，之后的所有第一界面都有了警告黄字。</p>
<p>然后就可以开始体验ColorOS15了，这动画，小米这辈子都做不出来啊，我个人是真的喜欢堆叠式的UI，包括堆叠桌面和堆叠通知，感觉非常流畅非常舒服，我想把红米root的一大理由也是因为想体验一下堆叠桌面。</p>
<p><video src="E:\blog\source\_posts\一加13从购买到毕业\961f5165330fc17d8aa8808cab1dc905.mp4"></video></p>
<p>而且ColorOS的动画非常之多，包括返回的手势动画，非常灵动，唯一跟小米的差别是，目前的澎湃2.0有通知栏下拉动画，那个动画确实好看，这个ColorOS上也确实没有，不过倒也无伤大雅了。</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2025-07-21_232448_201.jpg" alt="微信图片_2025-07-21_232448_201"></p>
<p>这是他套了原装后盖的样子，手感还是不错的，略带磨砂的质感，这个蓝色也是挺好看的对我来说，就是感觉摄像头模组有点大了，不过也正常，毕竟一加13的摄像不差的，至少不是扫码级别了。</p>
<h2 id="玩机"><a href="#玩机" class="headerlink" title="玩机"></a>玩机</h2><p>我采用的是这几年兴起的，也算比较成熟的root方案，sukisu+gki内核，装gki内核主要是我刚好找到了适配一加13的gki内核，还保留了风驰内核，gki内核对应用的隐藏支持的很好，基本上使用gki内核加上隐藏应用列表再加上trick store就可以完美隐藏环境了（虽然我没有完全成功），刷入的方法也很简单，找到对应的ROM链接，使用大侠阿木的工具箱一键刷入就可以了，gki内核隐藏效果好，但是缺点就是比较耗电，也确实，我的功耗在后面卡在3w左右了，死活压不下来了，不过也能用了，虽然个人体感跟之前红米的续航差不多。具体刷的过程就省略了，这个在酷安上有很多保姆教程。、</p>
<h3 id="root和环境隐藏"><a href="#root和环境隐藏" class="headerlink" title="root和环境隐藏"></a>root和环境隐藏</h3><p><a href="https://www.coolapk.com/feed/66000852?s=ZGM3YzljMjMxZTZhNjdjZzY4N2U1NzY4ega1540"><strong>一加Root环境隐藏养老版—终极指南教程</strong></a>  这我参考的教程，跟着走就行了。</p>
<p><a href="https://www.coolapk.com/feed/66019325?s=ZWE4MTg2MzQxZTM2YmVjZzY4N2U1ODk1ega1543b3">一加13的最新SukiSUUltra内核!gki</a>   这是我使用的一加13的gki内核，听说这个内核稍微省了点电，就用了这个包。</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2025-07-21_231625_829.jpg" alt="微信图片_2025-07-21_231625_829"></p>
<p>这是最终效果图，我没选择KPM的版本，因为KPM单独支持的模块太少了，而且KPM的版本听说耗电很快而且bug也多。</p>
<p>然后这个时候再刷入一键隐藏包，其实这个一键隐藏包就是内置了常见的隐藏模块，包括zygisk，lsposed，隐藏应用列表，还有就是trick store，一个自动更新签名的模块，这个是为了过Google Play的验证的，如果不设置正确的密钥值，就会用不了ChatGPT，更有甚者Google Play都打不开（因为我就这样试过，当时差点崩溃想再重刷系统了），这个模块运行它的脚本就可以了，但是记得开科学上网。到这一步如果你不追求完美隐藏的话，就已经够了，正常使用不会有什么影响了。</p>
<p>但是这样子操作之后，你还会发现，你的密钥认证过不了，显示AOSP证书链是可以被篡改的，但是你确实已经可以用谷歌程序或者ChatGPT了，这个不用慌，网上有许多教程，说是需要一个对的keybox.xml的也有，但是我直接使用了另一个模块，模块链接贴在这里了<a href="https://www.coolapk.com/feed/65588584?s=Mjc3ZTJjODAxZTM2YmVjZzY4OTc5NDdmega1550">Tricky-Store-Assistant-Next模块</a>，按照教程的指示刷入模块，然后开梯子跑一边模块的脚本就可以过密钥认证了。</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/Screenshot_2025-08-10-02-36-08-93_6029a840d9ecf62.jpg" alt="Screenshot_2025-08-10-02-36-08-93_6029a840d9ecf62"></p>
<p>如图所示，就已经过了密钥认证了。</p>
<p>关于谷歌系列的启用，酷安也有相应的教程<a href="https://www.coolapk.com/feed/60346243?s=YWZmMjNmZjQxZTM2YmVjZzY4OTc5NTc5ega1550">ColorOs安装使用谷歌三件套</a>，就是从应用市场下载安装官方的Google Play，然后再登录自己的账号就可以了，但还要记得在设置里面打开谷歌的选项，如果登录不上，要么就是你的梯子不行，要么就是你没有过密钥认证，隐藏的非常差。</p>
<p>然后就是隐藏应用列表的配置，这个酷安也有比较完善的教程，推荐使用黑名单的模式，花点时间把所有有可能影响环境的模块和应用添加进去就可以了，这个比较简单。</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/Screenshot_2025-08-10-02-43-43-61_94ce8de2e58052e.jpg" alt="Screenshot_2025-08-10-02-43-43-61_94ce8de2e58052e"></p>
<p>这个是我的配置页面。</p>
<p>最终效果如下</p>
<p><img src="/2025/07/21/%E4%B8%80%E5%8A%A013%E4%BB%8E%E8%B4%AD%E4%B9%B0%E5%88%B0%E6%AF%95%E4%B8%9A/Screenshot_2025-08-10-02-42-09-71_aa90d5c381d1285.jpg" alt="Screenshot_2025-08-10-02-42-09-71_aa90d5c381d1285"></p>
<p>这个时候基本上在应用隐藏的方面就毕业了，记得勾选上你想要隐藏的软件，已经可以玩许多游戏了，我实测王者没任何问题，连以环境严格的暗区突围也没有任何问题，都玩了几天了没有拉闸。</p>
<p>还有就是关于lsposed的隐藏，其实最好的隐藏方案是压根不装lsposed，但是这对我来说根本不可能，我root的一大需求就是lsposed的模块，包括qa，wx，网易叼毛云等等，所以就需要隐藏lsposed，不过其实不隐藏也没什么关系，隐藏后可以多过一些环境检测app了。隐藏lsposed就是刷入一个去掉日志的lsposed模块而已，这个模块我在后面的magisk模块在一起分享吧</p>
<p>还有就是一些细节上的问题了，环境隐藏的学问挺深的，有的时候装了个什么东西或者移动了什么文件，环境隐藏就失效了，包括我上一个月环境隐藏的还比较好，我就没怎么管它了，日用了一个月后，环境突然出问题了，一些之前可以过的环境检测又不能过了，所以不用太过于担心环境隐藏，有gki内核，日常使用绝大多数都已经可以正常使用检测不出来了，银行，游戏，美团都没有任何问题。</p>
<h3 id="体验优化"><a href="#体验优化" class="headerlink" title="体验优化"></a>体验优化</h3><p>root后的重头戏就是安装一些模块或者lsposed软件，</p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构技巧记录</title>
    <url>/2025/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="数据结构技巧记录"><a href="#数据结构技巧记录" class="headerlink" title="数据结构技巧记录"></a>数据结构技巧记录</h1><p>算法刚刚入门，打算将一些需要死记硬背的算法模板和一些灵活的算法思路记录下来，以后可以复习或者思路整理。</p>
<h2 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h2><p>这是按照算法中所使用的数据结构进行分类整理的题目</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="图书整理"><a href="#图书整理" class="headerlink" title="图书整理"></a>图书整理</h4><h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,6,4,1]</p>
<p>输出：[1,4,6,3]</p>
<p>提示：</p>
<p>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; reverseBookList(ListNode* head) &#123;</span><br><span class="line">    stack&lt;int&gt; resultS;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    while (current != nullptr) &#123;</span><br><span class="line">        resultS.push(current-&gt;val);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!resultS.empty()) &#123;</span><br><span class="line">        result.push_back(resultS.top());</span><br><span class="line">        resultS.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是通过栈来实现链表转数组反转，先拿出链表的数据，存储到栈中间，再把栈转成数组</p>
<h2 id="思路分类"><a href="#思路分类" class="headerlink" title="思路分类"></a>思路分类</h2><p>这是根据思路技巧的不同进行分类</p>
<h3 id="定长滑窗"><a href="#定长滑窗" class="headerlink" title="定长滑窗"></a>定长滑窗</h3><h4 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a>原链接</h4><p><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>碰到这样的给定长度的窗口，然后窗口可以自由移动，让你求出不同窗口中的一些东西，比如这道题，就是在定长窗口中找到元音字母最多的数量，比较典型的定长滑窗的题目，通用的思路是三步：进入-更新-出来，窗口右端点在 <em>i</em> 时，由于窗口长度为 <em>k</em>，所以窗口左端点为 <em>i</em>−<em>k</em>+1。</p>
<ol>
<li><p>进入：下标为 i 的元素进入循环后，更新统计量，就是数据处理，更新完后还需要判断窗口是否形成，如果左端点 i - k + 1 小于0，则continue跳过后面的循环</p>
</li>
<li><p>更新：然后更新答案，就是再次处理进入中的数据</p>
</li>
<li><p>出来：就是在窗口滑动，窗口的左边出来的时候，判断左边的情况，就是判断原左端点i-k+1的数据对整个的结果会不会有影响，这里再次更新统计量，数据处理</p>
</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>||s[i]==<span class="string">&#x27;e&#x27;</span>||s[i]==<span class="string">&#x27;i&#x27;</span>||s[i]==<span class="string">&#x27;o&#x27;</span>||s[i]==<span class="string">&#x27;u&#x27;</span>)<span class="comment">//进入</span></span><br><span class="line">                ans++;</span><br><span class="line">            <span class="keyword">if</span>(i-k<span class="number">+1</span>&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;maxans)<span class="comment">//更新</span></span><br><span class="line">                maxans = ans;</span><br><span class="line">            <span class="keyword">if</span>(s[i-k<span class="number">+1</span>]==<span class="string">&#x27;a&#x27;</span>||s[i-k<span class="number">+1</span>]==<span class="string">&#x27;e&#x27;</span>||s[i-k<span class="number">+1</span>]==<span class="string">&#x27;i&#x27;</span>||s[i-k<span class="number">+1</span>]==<span class="string">&#x27;o&#x27;</span>||s[i-k<span class="number">+1</span>]==<span class="string">&#x27;u&#x27;</span>)<span class="comment">//出来</span></span><br><span class="line">                ans = ans<span class="number">-1</span>;                 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>长理校园网多设备破解</title>
    <url>/2025/08/29/%E9%95%BF%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="长理校园网多设备破解"><a href="#长理校园网多设备破解" class="headerlink" title="长理校园网多设备破解"></a>长理校园网多设备破解</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为我苦于随身wifi的龟速（就算运气好信号好，跑满也只有20m），所以打算办一个校园网，但是众所周知，在长理办的校园网非常的不划算，平均一个月一台设备就要30元，如果你只花了30元买了无线的套餐，那么你就只能要么用wifi连接手机，要么用wifi连接电脑，总之是不可能同时连接的，性价比非常低，你如果想手机电脑同时连接的话，就需要购买60元的套餐，而且也只能电脑连接有线，手机连接wifi，非常的难受和昂贵，于是乎我也想到了关于长理校园网多设备破解的内容，所以也打算尝试买一台路由器或者软路由绕过长理校园网的多设备限制，刚好我也认识了一些大佬，他们提供了我许多思路和步骤。</p>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><h3 id="路由器购买"><a href="#路由器购买" class="headerlink" title="路由器购买"></a>路由器购买</h3><p>我首先打算选择的路由器是红米ax3000，这个价格比较便宜，而且基本功能都具备，也非常好刷机刷openwrt，但是我后来偶然在百度贴吧上发现了他们关于红米ax3000的讨论，好像性能有点不够，比较难流畅运行openclash，而openclash就是破解校园网多设备和路由器层面科学上网的关键步骤，所以我只能另外寻找其他的替代品，当时还打算买红米ax6000，但是一看感觉价格太贵了，性价比有限，后来偶然在恩山无线论坛逛的时候，发现了一台叫做京东云亚瑟的机子，价格便宜，也非常适合我目前的使用，京东云亚瑟是之前京东推出的类似网心云的占用你上传宽带的赚钱小东西，但现在京东官方也买不到，只能从咸鱼二手买，因为这台机子刷机有点复杂，需要拆机短接进9008，所以我为了省事，直接从咸鱼买了成品。</p>
<p><img src="/2025/08/29/%E9%95%BF%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%A0%B4%E8%A7%A3/Screenshot_2025-08-28-01-08-51-29_0dff84d2da4d0ad.jpg" alt="Screenshot_2025-08-28-01-08-51-29_0dff84d2da4d0ad"></p>
<p>这是配置列表，我花了70包邮买的，事实证明，我的选择没有问题，使用起来非常流程，最终也完成了校园网多设备的破解，速度也很快，内网测速有千兆，无线网络也可以跑满校园网的速度。</p>
<p><img src="/2025/08/29/%E9%95%BF%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%A0%B4%E8%A7%A3/1756489910445_compressed.jpg" alt="1756489910445_compressed"></p>
<p>这是它的具体长相，可以看到还是比较好看的，整体也比较新，到手联上网线和电源就可以配置ImmortalWrt了，这个ImmortalWrt其实就是openwrt的闭源版本，针对京东云亚瑟这台机子做了专门的驱动，效果还是不错的，一开始也内置了许多的插件，还有应用商店，整体来说话还是比较好用的。</p>
<h3 id="校园网多设备破解"><a href="#校园网多设备破解" class="headerlink" title="校园网多设备破解"></a>校园网多设备破解</h3><p>接下来讲解和分析校园网多设备破解的步骤。</p>
<h4 id="统一ttl"><a href="#统一ttl" class="headerlink" title="统一ttl"></a>统一ttl</h4><p>这是首先要做的，也不难，只需要打开openwrt的系统栏的启动项的部分，然后在本地启动脚本中加上	<strong>iptables -t mangle -I POSTROUTING -o br-lan -j TTL –ttl-set 128</strong>	这一行即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Put your custom commands here that should be executed once</span><br><span class="line"># the system init finished. By default this file does nothing.</span><br><span class="line">iptables -t mangle -I POSTROUTING -o br-lan -j TTL --ttl-set 128</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>最终效果如图所示，但是首先先确认是否安装了<strong>iptables</strong>，如果没有安装，就需要执行一下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opkg install iptables</span><br></pre></td></tr></table></figure>

<p>不过大部分linux系统都预装了<strong>iptables</strong>，这个不需要太担心。</p>
<h4 id="统一ua"><a href="#统一ua" class="headerlink" title="统一ua"></a>统一ua</h4><p>接下来要做的就是统一浏览器的UA，让网络认为我们是同一个客户端在访问，这里就需要用到一个插件<strong>ua3f</strong>，<a href="https://github.com/SunBK201/UA3F%EF%BC%8C%E8%BF%99%E6%98%AF%E5%AE%83%E7%9A%84github%E4%B8%BB%E9%A1%B5%EF%BC%8C%E6%8C%89%E7%85%A7readme%E7%9A%84%E5%86%85%E5%AE%B9%E5%AE%89%E8%A3%85%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%E8%AE%B0%E5%BE%97%E9%87%8D%E5%90%AF%E6%88%96%E8%80%85%E5%88%B7%E6%96%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E7%84%B6%E5%90%8E%E5%90%AF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E3%80%82">https://github.com/SunBK201/UA3F，这是它的github主页，按照readme的内容安装这个插件即可，安装完成后记得重启或者刷新客户端，然后启用这个插件。</a></p>
<p>然后我们要做的就是安装openclash或者shellcrash了，两个都是运行在openwrt系统上面的系统代理软件，其中shellcrash占用的内存相对要小一些。</p>
<p>我首先安装的是openclash，我先是安装了旧版本的openclash，结果发现代理始终启动不了，然后更新了新版本的openclash后，又有新的问题了，就是正常配置后启动后没有效果，并没有隐藏UA，我于是只好装了shellcrash，这次就比较成功了，安装成功了，更新meta内核和运行也没什么问题，非常好。</p>
<p>具体的安装步骤可以参考这篇文章，写的非常详细，<a href="https://sunbk201public.notion.site/UA3F-Clash-16d60a7b5f0e457a9ee97a3be7cbf557?pvs=4">UA3F和clash配置</a></p>
<p>接下来就是导入ua3f的配置到clash里面，也就是启用ua3f。</p>
<p>一共有三个版本的供你选择：</p>
<ol>
<li><a href="https://cdn.jsdelivr.net/gh/SunBK201/UA3F@master/clash/ua3f-cn.yaml">ua3f-cn.yaml</a> 这个版本就是只有针对国内平台做了处理，就是可以代理所有的http和https的请求，并且修改UA，没有做科学上网的处理</li>
<li><a href="https://cdn.jsdelivr.net/gh/SunBK201/UA3F@master/clash/ua3f-global.yaml">ua3f-global.yaml </a>这个版本就是既修改了UA，并且还加了科学上网的内容，只需要在 <strong>proxy-providers &gt; Global-ISP &gt; url 中(第 23 行)</strong> 加上你的代理的订阅链接即可，就会自动帮你订阅链接并且使用了。</li>
<li><a href="https://cdn.jsdelivr.net/gh/SunBK201/UA3F@master/clash/ua3f-global-enhance.yaml">ua3f-global-enhance.yaml </a> 这个版本就是在第二个版本上又做了处理，还针对了微信和QQ的流量做了处理，如果你的校园网检测比较严格的话，就需要用到这个版本，如果你没有小号的需求，就是微信和QQ都只有一个号，那也就没有配置的必要，不过我有几个QQ小号，所以我使用了这个脚本。</li>
</ol>
<p>选择好版本后，下载下来，然后重命名为config.yaml，然后上传到&#x2F;tmp文件夹中，这个步骤可以直接看自己系统，我的系统可以直接可视化文件管理，直接上传即可，然后再重启shellcrash，就会提示你导入配置文件了，导入然后再重启，所有步骤就完成了。</p>
<p>当然你如果采用的openclash，也类似，openclash可以直接导入yaml文件，你直接在openclash里上传你的配置文件即可。</p>
<p>下载好后，一定要记得重启，直到显示这个</p>
<p><img src="/2025/08/29/%E9%95%BF%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%A0%B4%E8%A7%A3/PixPin_2025-09-06_01-07-29.jpg" alt="PixPin_2025-09-06_01-07-29"></p>
<p>只要显示正在运行就可以了，模式无所谓。ShellCrash的固定是meta内核，不需要修改内核，openclash就需要记得切换成meta内核。</p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>目前版本的校园网，只需要做好这两个配置就可以完美破解校园网了，并且ua3f的配置也不需要选择那个针对微信和QQ做了特殊处理的规则，前两个就完全够使用了。</p>
<p>接下来只需要按照你的需求，要么插上网线，要么开启WiFi，体验多设备享受校园网的速度吧。</p>
<h2 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h2><h3 id="udp启用"><a href="#udp启用" class="headerlink" title="udp启用"></a>udp启用</h3><p>虽然已经完成了校园网的多设备破解，但我实测下来还是有点小问题，比如不能使用udp，这样子玩三角洲等大型枪战游戏就会很卡，甚至根本连不上。</p>
<p>这个的解决方法是在ua3f的clash的config里面udp转发打开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line"># Written by SunBK201</span><br><span class="line"># https://github.com/SunBK201/UA3F</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">mixed-port: 7890</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">ipv6: false</span><br><span class="line">mode: rule</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">dns:</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">proxies:</span><br><span class="line">  - name: &quot;ua3f&quot;</span><br><span class="line">    type: socks5</span><br><span class="line">    server: 127.0.0.1</span><br><span class="line">    port: 1080</span><br><span class="line">    url: http://connectivitycheck.platform.hicloud.com/generate_204</span><br><span class="line">    udp: true      //把这里改成true即可</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">proxy-providers:</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">proxy-groups:</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">rules:</span><br><span class="line">  - NETWORK,udp,DIRECT</span><br><span class="line">  - MATCH,ua3f</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">rule-providers:</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br><span class="line">parsers:</span><br><span class="line">#--------------------------------------------------------------------------------------#</span><br></pre></td></tr></table></figure>

<p>同理另外两个文件也可以这么设置。</p>
<p>设置完成以后，就可以流畅玩三角洲，cs等游戏了。</p>
<h3 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h3><p>因为长理连上了校园网后，虽然会分配一个内网IPV4的地址和外网IPV6，但是别看到外网IPV6就太兴奋了，长理应该对外网访问做了防火墙的限制，不能直接访问，虽然上传速度快，但是跑PCDN还是收益不大的。</p>
<p>为了可以远程访问路由器，然后配合远程唤醒命令，远程开机电脑，可以使用Tailscale插件，直接在iStore安装即可，配置好账户和手机app后，开启vpn，就可以远程连接路由器，速度只能说勉强能用。</p>
<p><img src="/2025/08/29/%E9%95%BF%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%A0%B4%E8%A7%A3/Screenshot_2025-09-06-01-56-34-23_05d38dbdcca0dac.jpg" alt="Screenshot_2025-09-06-01-56-34-23_05d38dbdcca0dac"></p>
<p><img src="/2025/08/29/%E9%95%BF%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%A0%B4%E8%A7%A3/Screenshot_2025-09-06-01-58-56-35_a252b927494330c.jpg" alt="Screenshot_2025-09-06-01-58-56-35_a252b927494330c"></p>
<p>使用截图如上</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>参考链接：</p>
<p><a href="https://blog.zhelearn.com/2024/10/20/csust-campus-network-sharing-detection/">https://blog.zhelearn.com/2024/10/20/csust-campus-network-sharing-detection/</a></p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
