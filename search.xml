<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>teat_life</title>
    <url>/2024/11/02/teat-life/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/2024/11/02/test/</url>
    <content><![CDATA[<p>Markdown 是一种轻量级的标记语言，用于格式化纯文本。它允许您以简单的方式添加格式，而不需要复杂的 HTML 标签。以下是一些常用的 Markdown 语法：</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h4 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个段落。</span><br><span class="line"></span><br><span class="line">这是另一个段落。</span><br></pre></td></tr></table></figure>

<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">__粗体__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体_</span>__</span></span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li><p><strong>无序列表</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表项1</span><br><span class="line"><span class="bullet">-</span> 列表项2</span><br><span class="line"><span class="bullet">-</span> 列表项3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有序列表</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表项1</span><br><span class="line"><span class="bullet">2.</span> 列表项2</span><br><span class="line"><span class="bullet">3.</span> 列表项3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>嵌套列表</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表项1</span><br><span class="line"><span class="bullet">   -</span> 子列表项1</span><br><span class="line"><span class="bullet">   -</span> 子列表项2</span><br><span class="line"><span class="bullet">2.</span> 列表项2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接文本</span>](<span class="link">URL</span>)</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">替代文本</span>](<span class="link">图片URL</span>)</span><br></pre></td></tr></table></figure>

<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul>
<li><p><strong>内联代码</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`这是内联代码`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多行代码块</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```语言</span></span><br><span class="line"><span class="code">这是多行代码块</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 引用</span><br><span class="line">```markdown</span><br><span class="line">&gt; 这是一个引用块。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 列1 | 列2 | 列3 |</span><br><span class="line">| --- | --- | --- |</span><br><span class="line">| 内容1 | 内容2 | 内容3 |</span><br><span class="line">| 内容4 | 内容5 | 内容6 |</span><br></pre></td></tr></table></figure>

<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>

<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成的任务</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成的任务</span><br></pre></td></tr></table></figure>

<h4 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">:smile:</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 我的第一篇 Markdown 文章</span></span><br><span class="line"></span><br><span class="line">这是一个段落。接下来是一些 <span class="strong">**粗体**</span> 和 <span class="emphasis">*斜体*</span> 的文字。</span><br><span class="line"></span><br><span class="line"><span class="section">## 子标题</span></span><br><span class="line"></span><br><span class="line">这是一个无序列表：</span><br><span class="line"><span class="bullet">-</span> 列表项1</span><br><span class="line"><span class="bullet">-</span> 列表项2</span><br><span class="line"><span class="bullet">-</span> 列表项3</span><br><span class="line"></span><br><span class="line">这是一个有序列表：</span><br><span class="line"><span class="bullet">1.</span> 列表项1</span><br><span class="line"><span class="bullet">2.</span> 列表项2</span><br><span class="line"><span class="bullet">3.</span> 列表项3</span><br><span class="line"></span><br><span class="line">这是一个链接：[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)</span><br><span class="line"></span><br><span class="line">这是一个图片：</span><br><span class="line">![<span class="string">Markdown Logo</span>](<span class="link">https://markdown-guide-images.vercel.app/logo-markdown.png</span>)</span><br><span class="line"></span><br><span class="line">这是一个代码块：</span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">def hello_world():</span></span><br><span class="line"><span class="code">    print(&quot;Hello, world!&quot;)</span></span><br></pre></td></tr></table></figure>

<p>这是一个引用：</p>
<blockquote>
<p>这是一个引用块。</p>
</blockquote>
<h2 id="这是一个水平线："><a href="#这是一个水平线：" class="headerlink" title="这是一个水平线："></a>这是一个水平线：</h2><p>这是一个表格：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>年龄</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>25</td>
<td>北京</td>
</tr>
<tr>
<td>李四</td>
<td>30</td>
<td>上海</td>
</tr>
</tbody></table>
<p>这是一个删除线：<br><del>错误的信息</del></p>
<p>这是一个任务列表：</p>
<ul>
<li><input checked disabled type="checkbox"> 已完成的任务</li>
<li><input disabled type="checkbox"> 未完成的任务</li>
</ul>
<p>这是一个表情符号：<br>:smile:</p>
<pre><code>
希望这些示例和语法能帮助您更好地使用 Markdown。如果您有任何具体问题或需要进一步的帮助，请随时提问！
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>11月札记</title>
    <url>/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h3><p>图书协会活动——图书馆看番</p>
<p>也是喜欢上了老八。</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/6778B314F59B2F02621AC44DD791A6E0.jpg" alt="6778B314F59B2F02621AC44DD791A6E0"></p>
<p>顺便记录一下图书馆地图</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/92407026223B2A53F8948AED0117C7E0.jpg" alt="92407026223B2A53F8948AED0117C7E0"></p>
<h3 id="11-4"><a href="#11-4" class="headerlink" title="11.4"></a>11.4</h3><p>西门外的卤肉店</p>
<p><img src="/2024/11/05/11%E6%9C%88%E6%9C%AD%E8%AE%B0/15FF5EAD53B8A222749F1B697FAE7BD0.jpg" alt="15FF5EAD53B8A222749F1B697FAE7BD0"></p>
<p>这一碗加上饭才13，也是爽爽的吃撑了。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>札记</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机实践系列合集</title>
    <url>/2024/11/12/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="此板块用来记录一些成熟的单片机程序"><a href="#此板块用来记录一些成熟的单片机程序" class="headerlink" title="此板块用来记录一些成熟的单片机程序"></a>此板块用来记录一些成熟的单片机程序</h1><h2 id="矩阵键盘密码锁"><a href="#矩阵键盘密码锁" class="headerlink" title="矩阵键盘密码锁"></a>矩阵键盘密码锁</h2><p>通过矩阵键盘输入数字，再调用lcd1602提供显示功能，来实现简单的验证密码的功能。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;lcd1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Martrixkey.h&quot;           //引入一系列的库</span></span><br><span class="line">unsigned int password,count;		//定义了密码变量跟计数变量</span><br><span class="line">unsigned char KeyNum;			//定义键码</span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	LCD_Init();</span></span><br><span class="line"><span class="code">	LCD_ShowString(1,1,&quot;Password:&quot;);	//初始化界面</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		KeyNum=MartrixKey();		//读取键位</span></span><br><span class="line"><span class="code">		if(KeyNum)</span></span><br><span class="line"><span class="code">		&#123;	if(KeyNum&lt;=10)		//计数代码</span></span><br><span class="line"><span class="code">				&#123;	</span></span><br><span class="line"><span class="code">					if(count&lt;4)</span></span><br><span class="line"><span class="code">					&#123;</span></span><br><span class="line"><span class="code">					password*=10;</span></span><br><span class="line"><span class="code">					password+=KeyNum%10;		//通过将原先的变量*10再加上现在的变量</span></span><br><span class="line"><span class="code">					count++;		//计数用，计数达到了4再输入就不会有任何结果了</span></span><br><span class="line"><span class="code">					&#125;</span></span><br><span class="line"><span class="code">					LCD_ShowNum(2,1,password,4);		//实时更新显示</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">			if(KeyNum==11)		//制作完成功能</span></span><br><span class="line"><span class="code">			&#123;</span></span><br><span class="line"><span class="code">				if(password==1145)		//密码值</span></span><br><span class="line"><span class="code">				&#123;</span></span><br><span class="line"><span class="code">					LCD_ShowString(1,14,&quot;OK &quot;);</span></span><br><span class="line"><span class="code">					password = 0;		//清零变量值</span></span><br><span class="line"><span class="code">					count=0;</span></span><br><span class="line"><span class="code">					LCD_ShowNum(2,1,password,4);</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">				else</span></span><br><span class="line"><span class="code">				&#123;</span></span><br><span class="line"><span class="code">					LCD_ShowString(1,14,&quot;ERR&quot;);</span></span><br><span class="line"><span class="code">					password = 0;</span></span><br><span class="line"><span class="code">					count=0;</span></span><br><span class="line"><span class="code">					LCD_ShowNum(2,1,password,4);</span></span><br><span class="line"><span class="code">				&#125;</span></span><br><span class="line"><span class="code">			</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">			if(KeyNum==12)		//清空按键</span></span><br><span class="line"><span class="code">			&#123;password=0;count=0;LCD_ShowNum(2,1,password,4);&#125;</span></span><br><span class="line"><span class="code">			//if(KeyNum==12)</span></span><br><span class="line"><span class="code">			//&#123;password=(password-password%10)/10;count--;LCD_ShowNum(2,1,password,4);&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>还有另一个版本，我做了些微调，以注释的形式添加到代码中了，作用的区别是一个直接赋值清空输入栏，第二种是减去后一位数字。</p>
<h2 id="电子时钟-计时器"><a href="#电子时钟-计时器" class="headerlink" title="电子时钟&#x2F;计时器"></a>电子时钟&#x2F;计时器</h2><p>通过定时器实现计时器或者电子时钟。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;LCD1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Timer0.h&quot;</span></span><br><span class="line">unsigned char Sec,min,hour;</span><br><span class="line">void main()</span><br><span class="line">&#123;			LCD<span class="emphasis">_Init();</span></span><br><span class="line"><span class="emphasis">	Timer0_</span>Init();</span><br><span class="line"><span class="code">	LCD_ShowString(1,1,&quot;Clock:&quot;);</span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">		 &#123;</span></span><br><span class="line"><span class="code">			 LCD_ShowNum(2,1,hour,2);</span></span><br><span class="line"><span class="code">			 LCD_ShowChar(2,3,&#x27;:&#x27;);</span></span><br><span class="line"><span class="code">			 LCD_ShowNum(2,4,min,2);</span></span><br><span class="line"><span class="code">			 LCD_ShowChar(2,6,&#x27;:&#x27;);</span></span><br><span class="line"><span class="code">			 LCD_ShowNum(2,7,Sec,2);	 </span></span><br><span class="line"><span class="code">		 &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void Timer0_Routine() interrupt 1				</span></span><br><span class="line"><span class="code">&#123;	static signed int T0Count;</span></span><br><span class="line"><span class="code">	TL0 = 0x66;		</span></span><br><span class="line"><span class="code">	TH0 = 0xFC;	</span></span><br><span class="line"><span class="code">	T0Count++;</span></span><br><span class="line"><span class="code">	if(T0Count&gt;=1000)</span></span><br><span class="line"><span class="code">	&#123;	T0Count=0;</span></span><br><span class="line"><span class="code">		Sec++;</span></span><br><span class="line"><span class="code">		if(Sec&gt;=60)</span></span><br><span class="line"><span class="code">		&#123;Sec=0;</span></span><br><span class="line"><span class="code">			min++;</span></span><br><span class="line"><span class="code">			if(min&gt;=60)</span></span><br><span class="line"><span class="code">			&#123;hour++;</span></span><br><span class="line"><span class="code">				if(hour&gt;=24)</span></span><br><span class="line"><span class="code">					hour=0;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>程序运行后，会从00：00：00开始计时，如果想当作时钟，也只用调整适当的Sec，min，hour初始命令即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机系列</title>
    <url>/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="单片机系列"><a href="#单片机系列" class="headerlink" title="单片机系列"></a>单片机系列</h1><p>此文章记录我学单片机进程，以及所写的代码集合，当作笔记和备份吧，以后可以温习用。</p>
<p>目前正在学的是51单片机，普中A2版本。</p>
<p>先上张原理图</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/%E6%99%AE%E4%B8%AD-2&%E6%99%AE%E4%B8%AD-3&%E6%99%AE%E4%B8%AD-4%E5%BC%80%E5%8F%91%E6%9D%BF%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="开发板原理图"></p>
<p>再来张十六进制换算表</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/CRnall_20241103_004139503.jpg" alt="十六进制"></p>
<h2 id="LED模块"><a href="#LED模块" class="headerlink" title="LED模块"></a>LED模块</h2><h3 id="最简单的点灯代码"><a href="#最简单的点灯代码" class="headerlink" title="最简单的点灯代码"></a>最简单的点灯代码</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	P2 = 0xFE;</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>



<h3 id="控制点灯时间代码"><a href="#控制点灯时间代码" class="headerlink" title="控制点灯时间代码"></a>控制点灯时间代码</h3><p>通过软件内置的时间延迟计算生成函数，来控制时间。</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/blog\source_posts\51单片机系列\CRnall_20241103_233001031.jpg" alt="CRnall_20241103_233001031"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">INTRINS.H</span>&gt;</span></span></span></span><br><span class="line">void Delay500ms()		//@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	unsigned char i, j, k;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	_nop_();</span></span><br><span class="line"><span class="code">	i = 4;</span></span><br><span class="line"><span class="code">	j = 205;</span></span><br><span class="line"><span class="code">	k = 187;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		do</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			while (--k);</span></span><br><span class="line"><span class="code">		&#125; while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">void main()</span><br><span class="line">&#123; </span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">	P2=0xFE;</span></span><br><span class="line"><span class="code">	Delay500ms();	</span></span><br><span class="line"><span class="code">	P2=0xFF;</span></span><br><span class="line"><span class="code">	Delay500ms();</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="流水灯代码"><a href="#流水灯代码" class="headerlink" title="流水灯代码"></a>流水灯代码</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">void Delay1ms(unsigned int xms)		//@12MHz</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	unsigned char i, j;</span></span><br><span class="line"><span class="code">	while(xms)&#123;</span></span><br><span class="line"><span class="code">		i = 2;</span></span><br><span class="line"><span class="code">		j = 239;</span></span><br><span class="line"><span class="code">		do</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			while (--j);</span></span><br><span class="line"><span class="code">		&#125; while (--i);</span></span><br><span class="line"><span class="code">		xms--;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		P2=0xFE;</span></span><br><span class="line"><span class="code">		Delay1ms(120);</span></span><br><span class="line"><span class="code">		P2=0xFD;</span></span><br><span class="line"><span class="code">		Delay1ms(500);</span></span><br><span class="line"><span class="code">		P2=0xFB;</span></span><br><span class="line"><span class="code">		Delay1ms(100);</span></span><br><span class="line"><span class="code">		P2=0xF7;</span></span><br><span class="line"><span class="code">		Delay1ms(200);</span></span><br><span class="line"><span class="code">		P2=0xEF;</span></span><br><span class="line"><span class="code">		Delay1ms(500);</span></span><br><span class="line"><span class="code">		P2=0xDF;</span></span><br><span class="line"><span class="code">		Delay1ms(400);</span></span><br><span class="line"><span class="code">		P2=0xBF;</span></span><br><span class="line"><span class="code">		Delay1ms(300);</span></span><br><span class="line"><span class="code">		P2=0x7F;</span></span><br><span class="line"><span class="code">		Delay1ms(100);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>通过调整函数变量，可以自由决定每一个灯亮起的时间跟间隔。</p>
<h3 id="按钮控制点灯v1"><a href="#按钮控制点灯v1" class="headerlink" title="按钮控制点灯v1"></a>按钮控制点灯v1</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">void main()</span><br><span class="line">&#123;	while(1)</span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		if(P3_1==0)</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			P2_0=0;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">		else</span></span><br><span class="line"><span class="code">			P2_0=1;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>可以通过按钮的判断来控制小灯的亮灭了，但是这些代码只能需要按钮一直按下才可以把灯点亮，如果松开按钮灯就灭了，而且没有消抖。</p>
<h3 id="按钮控制点灯v2"><a href="#按钮控制点灯v2" class="headerlink" title="按钮控制点灯v2"></a>按钮控制点灯v2</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line">void Delay1ms(unsigned int xms)		//@12MHz</span><br><span class="line">&#123;	unsigned char i, j;</span><br><span class="line">while(xms&gt;0)&#123;</span><br><span class="line"><span class="code">	i = 2;</span></span><br><span class="line"><span class="code">	j = 239;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);</span></span><br><span class="line"><span class="code">	xms--;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;P2_0=0;</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		if(P3_1==0)</span></span><br><span class="line"><span class="code">		&#123;	Delay1ms(20);</span></span><br><span class="line"><span class="code">			while(P3_1==0);</span></span><br><span class="line"><span class="code">			Delay1ms(20);</span></span><br><span class="line"><span class="code">			P2_0=~P2_0;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>



<p>这个就相对完善了很多了，已经可以实现按钮按一次就会一直亮，再按就灭的功能，而且也加入了延时来消除抖动。也引入了位运算，可以通过取反来更加便捷地控制小灯亮灭。</p>
<h3 id="按钮控制点灯v3"><a href="#按钮控制点灯v3" class="headerlink" title="按钮控制点灯v3"></a>按钮控制点灯v3</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">char LEDNum=0;</span><br><span class="line">void delay(int xms)		//@12MHz</span><br><span class="line">&#123;while(xms)</span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	unsigned char i, j;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	i = 2;</span></span><br><span class="line"><span class="code">	j = 239;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);</span></span><br><span class="line"><span class="code">	xms--;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;	 P2=~0x01;</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;	</span></span><br><span class="line"><span class="code">		if(P3_1==0)     //实现左移</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			delay(30);</span></span><br><span class="line"><span class="code">			while(P3_1==0)</span></span><br><span class="line"><span class="code">			delay(30);</span></span><br><span class="line"><span class="code">			LEDNum++;</span></span><br><span class="line"><span class="code">			if(LEDNum==8)</span></span><br><span class="line"><span class="code">				LEDNum=0;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">			P2 =~(0x01&lt;&lt;LEDNum);</span></span><br><span class="line"><span class="code">				if(P3_0==0)  //实现右移</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			delay(30);</span></span><br><span class="line"><span class="code">			while(P3_0==0)</span></span><br><span class="line"><span class="code">			delay(30);	</span></span><br><span class="line"><span class="code">			if(LEDNum==0)</span></span><br><span class="line"><span class="code">				LEDNum=7;		</span></span><br><span class="line"><span class="code">			else</span></span><br><span class="line"><span class="code">				LEDNum--;</span></span><br><span class="line"><span class="code">			P2 =~(0x01&lt;&lt;LEDNum);		</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>通过if语句和一个中间变量再加上移位运算和取反运算，最终实现了用两个按钮来控制小灯的亮起的左移和右移，并且对小灯在边缘亮起的情况做了处理，让其可以正常运行。</p>
<h2 id="静态数码管显示"><a href="#静态数码管显示" class="headerlink" title="静态数码管显示"></a>静态数码管显示</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">unsigned char nixietable[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00&#125;;</span><br><span class="line">void nixie(unsigned char location,number)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	switch(location)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		case 1:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 2:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 3:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 4:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 5:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 6:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 7:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 8:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=0;break;	</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">P0=nixietable[number];</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;	nixie(2,3);</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>定义了一个nixie的函数，用来更为方便的控制静态数码管，数码管的控制主要有两个来决定，一个是位，一个是数，在51单片机中，代码中的switch判断所控制的就是数码管的位置，采用的是38译码器，通过三个数的0和1来表示8个位置的数码管，大限度的减短控制所需要的接口，非常的巧妙，而代码中的nixietable数组则是控制显示的数字，通过十六进制的数字来控制所显示的东西，一切都刚刚好，具体可以去看原理图，如果使用的话，调用现成的库就足够了。</p>
<p>但是，这套控制系统虽然简单，只用了很少的接口，但是也有局限性，就是一次只能表示一个位置的一个数字，所以就有了动态数码管。</p>
<h2 id="动态数码管"><a href="#动态数码管" class="headerlink" title="动态数码管"></a>动态数码管</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">unsigned char nixietable[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00&#125;;</span><br><span class="line">void delay(int xms)		//@12MHz</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	unsigned char i, j;</span></span><br><span class="line"><span class="code">while(xms)&#123;</span></span><br><span class="line"><span class="code">	i = 2;</span></span><br><span class="line"><span class="code">	j = 239;</span></span><br><span class="line"><span class="code">	do</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		while (--j);</span></span><br><span class="line"><span class="code">	&#125; while (--i);xms--;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void nixie(unsigned char location,number)</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">	switch(location)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		case 1:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 2:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 3:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 4:</span></span><br><span class="line"><span class="code">			P2_4=1;P2_3=0;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 5:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 6:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=1;P2_2=0;break;</span></span><br><span class="line"><span class="code">		case 7:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=1;break;</span></span><br><span class="line"><span class="code">		case 8:</span></span><br><span class="line"><span class="code">			P2_4=0;P2_3=0;P2_2=0;break;	</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">P0=nixietable[number];</span></span><br><span class="line"><span class="code">delay(1);</span></span><br><span class="line"><span class="code">	P0=0x00;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;	</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	nixie(1,1);delay(5);</span></span><br><span class="line"><span class="code">	nixie(2,2);delay(5);</span></span><br><span class="line"><span class="code">	nixie(3,3);delay(5);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这个就已经比较完善了，通过delay延时，利用人眼的延时，只要变化的够快，人眼就感知不出来（doge）。</p>
<p>同时呢，也加入了消隐，可以避免数码管显示出错，当然，也可以让延时改为1毫秒，也可以避免显示出错。</p>
<p><img src="/2024/11/03/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E5%88%97/8C07D227036A5E8622746F2B68EEAFC0.jpg" alt="666显示"></p>
<h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p>这是一种方法，我们可以将一些函数打包成一个.c文件和一个.h文件，只要做好声明并调用，就可以非常方便的使用这些函数了，并且也容易分享和修改。</p>
<p>下面是一个.h文件的示例</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#ifndef <span class="strong">__DELAY<span class="emphasis">_H_</span>_</span></span></span><br><span class="line"><span class="strong"><span class="section">#define __</span>DELAY<span class="emphasis">_H_</span>_</span></span><br><span class="line">void delay(int xms);</span><br><span class="line"><span class="section">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>.c文件就是类似于自定义函数的写法，放在同一目录下就可以正常使用了。</p>
<h2 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h2><p>为了简化io口，矩阵键盘也应用了类似于数码管的模式，仅使用了8个io口，便可以控制了16个矩阵按键，相应的，获取矩阵按键的状态，也是需要不断扫描，以时间赢得空间。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;lcd1602.h&quot;</span></span><br><span class="line">/**</span><br><span class="line"><span class="bullet">  *</span> @brief  矩阵键盘读取按健键码</span><br><span class="line"><span class="bullet">  *</span> @param  无</span><br><span class="line"><span class="bullet">  *</span> @retval 按下按键的键码值</span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">unsigned char Martrixkey()</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	unsigned char KeyNumber = 0;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_3=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=1;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=5;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=9;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=13;&#125;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_2=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=2;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=6;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=10;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=14;&#125;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_1=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=3;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=7;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=11;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=15;&#125;</span></span><br><span class="line"><span class="emphasis">	P1=0xFF;</span></span><br><span class="line"><span class="emphasis">	P1_0=0;</span></span><br><span class="line"><span class="emphasis">	if(P1_7==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=4;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_6==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=8;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_5==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=12;&#125;</span></span><br><span class="line"><span class="emphasis">	if(P1_4==0)</span></span><br><span class="line"><span class="emphasis">	&#123;delay(20);while(P1_7==0);delay(20);KeyNumber=16;&#125;</span></span><br><span class="line"><span class="emphasis">	return KeyNumber;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这是矩阵键盘模块的内部代码，以按列扫描的模式，不断读取每个按键的状态，并返回相对应的结果。</p>
<p>下面是一个简单的矩阵键盘使用案例。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;lcd1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Martrixkey.h&quot;</span></span><br><span class="line">unsigned char KeyNum;</span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	LCD_Init();</span></span><br><span class="line"><span class="code">	LCD_ShowString(1,2,&quot;Hello world&quot;);</span></span><br><span class="line"><span class="code">	while(1)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		KeyNum=MartrixKey();</span></span><br><span class="line"><span class="code">		if(KeyNum)</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			LCD_ShowNum(2,1,KeyNum,2);		</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这些代码通过调用矩阵键盘的模块可以实现读取键盘的数值，并让其实时打印在LCD屏幕上。</p>
<h2 id="定时器系列"><a href="#定时器系列" class="headerlink" title="定时器系列"></a>定时器系列</h2><p>delay函数之所以可以延时，是因为它通过让cpu执行一系列空的事情，来拖延出时间，所以当我们在运行delay函数时，cpu是占满的，我们这个时候再想运行其他函数，cpu是不会响应的，有弊端在，所以，引入了一个重要的模块——<strong>定时器</strong>。</p>
<p>定时器，是芯片内部的资源，通过晶振来推动，51单片机定时器0内部有两个寄存器TH0和TL0,都是一字节的，理解位定时器0高位寄存器（TH0），定时器0低位寄存器（TL0）, 我们知道2字节最大能存0到65535一共65536个数字。每过一个指令周期（1us），寄存器的值+1，当加到溢出后发出一个溢出中断，我们程序可以捕获到这个中断，并执行中断函数内容，就可以知道此时经历了（65535+1）us。如果我们要定时1ms，设置寄存器的初值为64536，这样到溢出值65536就正好1ms。如果想要定时1s的话，设置一个计数器，让定时器循环1000次即可。</p>
<p>定时器由于是芯片内部的资源，所以不需要特别占用cpu，比delay好很多。</p>
<p>下面就是一个简单的由定时器驱动的程序。这是一个按键控制流水灯的程序，按下按键，流水灯就会换一个方向亮起，引入了第三方库INTRINS.h。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;Timer0.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Key.h&quot;</span></span><br><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">INTRINS.H</span>&gt;</span></span></span></span><br><span class="line">unsigned char KeyNum,LEDmode;</span><br><span class="line">void main()</span><br><span class="line">&#123;		P2=0xFE;</span><br><span class="line"><span class="code">		Timer0_Init(); </span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">	&#123;	</span></span><br><span class="line"><span class="code">		KeyNum=Key();</span></span><br><span class="line"><span class="code">		if(KeyNum)</span></span><br><span class="line"><span class="code">		&#123;	</span></span><br><span class="line"><span class="code">			if(KeyNum==1)</span></span><br><span class="line"><span class="code">			&#123;	</span></span><br><span class="line"><span class="code">				LEDmode++;</span></span><br><span class="line"><span class="code">				if(LEDmode&gt;=2)LEDmode=0;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void Timer0_Routine() interrupt 1		//中断程序内容</span></span><br><span class="line"><span class="code">&#123;	static signed int T0Count;</span></span><br><span class="line"><span class="code">	TL0 = 0x66;		</span></span><br><span class="line"><span class="code">	TH0 = 0xFC;	</span></span><br><span class="line"><span class="code">	T0Count++;</span></span><br><span class="line"><span class="code">	if(T0Count&gt;=1000)		//计次1000次以达到1s钟</span></span><br><span class="line"><span class="code">	&#123;	T0Count=0;</span></span><br><span class="line"><span class="code">		if(LEDmode==0)</span></span><br><span class="line"><span class="code">			P2=_crol_(P2,1);</span></span><br><span class="line"><span class="code">		if(LEDmode==1)</span></span><br><span class="line"><span class="code">			P2=_cror_(P2,1);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>



<p>像这种程序如果不用定时器而用delay是实现不了的，或者说效果很差，按键根本反应不了。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">void Timer0<span class="emphasis">_Init()</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	TMOD &amp;= 0xF0;		</span></span><br><span class="line"><span class="emphasis">	TMOD |= 0x01;		</span></span><br><span class="line"><span class="emphasis">	TL0 = 0x66;		</span></span><br><span class="line"><span class="emphasis">	TH0 = 0xFC;		</span></span><br><span class="line"><span class="emphasis">	TF0 = 0;		</span></span><br><span class="line"><span class="emphasis">	TR0 = 1;		</span></span><br><span class="line"><span class="emphasis">	ET0=1;</span></span><br><span class="line"><span class="emphasis">	EA=1;</span></span><br><span class="line"><span class="emphasis">	PT0=0;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这是定时器的内部寄存器配置。</p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>PWM是一种控制输出电功率的方法，就是控制高低电平的比例，从而控制电力的输出，常用的领域有呼吸灯的制作，还有电机的调速。</p>
<h3 id="呼吸灯"><a href="#呼吸灯" class="headerlink" title="呼吸灯"></a>呼吸灯</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line">sbit LED=P2^0;</span><br><span class="line">void delay(unsigned int t)  //简易延时函数</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">	while(t--);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">void main()</span></span><br><span class="line"><span class="code">&#123;		signed char time,t;</span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">&#123;	</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	for(time=0;time&lt;100;time++)</span></span><br><span class="line"><span class="code">	&#123; </span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		for(t=0;t&lt;20;t++)		//灯泡亮暗的速度太快了，加入这个循环，降低其速度</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			LED=0;</span></span><br><span class="line"><span class="code">			delay(time);</span></span><br><span class="line"><span class="code">			LED=1;</span></span><br><span class="line"><span class="code">			delay(100-time);</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">		for(time=100;time&gt;0;time--)</span></span><br><span class="line"><span class="code">	&#123; </span></span><br><span class="line"><span class="code">		</span></span><br><span class="line"><span class="code">		for(t=0;t&lt;20;t++)</span></span><br><span class="line"><span class="code">		&#123;</span></span><br><span class="line"><span class="code">			LED=0;</span></span><br><span class="line"><span class="code">			delay(time);</span></span><br><span class="line"><span class="code">			LED=1;</span></span><br><span class="line"><span class="code">			delay(100-time);</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个有用了delay的方法，有规律的控制小灯暗亮。</p>
<h3 id="电机调速"><a href="#电机调速" class="headerlink" title="电机调速"></a>电机调速</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Key.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;LCD1602.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;Martrixkey.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;nixie.h&quot;</span></span><br><span class="line">unsigned char counter,compare;</span><br><span class="line">unsigned char keynum,speed;</span><br><span class="line">sbit Motor = P1^0;</span><br><span class="line">void main()</span><br><span class="line">&#123;		Timer0<span class="emphasis">_Init();</span></span><br><span class="line"><span class="emphasis">     while(1)</span></span><br><span class="line"><span class="emphasis">&#123;	</span></span><br><span class="line"><span class="emphasis">	keynum=Key();</span></span><br><span class="line"><span class="emphasis">	if(keynum==1)</span></span><br><span class="line"><span class="emphasis">	&#123;</span></span><br><span class="line"><span class="emphasis">		speed++;</span></span><br><span class="line"><span class="emphasis">		speed%=4;</span></span><br><span class="line"><span class="emphasis">		if(speed==0)compare=0;</span></span><br><span class="line"><span class="emphasis">		if(speed==1)compare=50;</span></span><br><span class="line"><span class="emphasis">		if(speed==2)compare=75;</span></span><br><span class="line"><span class="emphasis">		if(speed==3)compare=100;</span></span><br><span class="line"><span class="emphasis">	&#125;</span></span><br><span class="line"><span class="emphasis">	nixie(1,speed);</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">void Timer0_</span>Routine() interrupt 1				</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	TL0 = 0xA4;		</span></span><br><span class="line"><span class="code">	TH0 = 0xFF;	</span></span><br><span class="line"><span class="code">	counter++;</span></span><br><span class="line"><span class="code">	if(counter&gt;100)</span></span><br><span class="line"><span class="code">	&#123;counter=0;				//counter%=100;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	if(counter&lt;compare)</span></span><br><span class="line"><span class="code">		Motor=1;</span></span><br><span class="line"><span class="code">	else</span></span><br><span class="line"><span class="code">		Motor=0;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一共有三档调速度，通过比较counter和compare两个变量的大小，来控制电机的运转与否。</p>
<h2 id="8-8点阵屏"><a href="#8-8点阵屏" class="headerlink" title="8*8点阵屏"></a>8*8点阵屏</h2><p>8*8点阵屏是一个由64个小灯组成的小屏幕，类似于矩阵键盘，也是通过时间换io口，总共只需要控制11个io口，就可以在点阵屏上显示内容，，采用的是按列扫描的模式，而控制每一列的内容，则是通过3个io口进行处理，需要74HC595模块，就想填子弹一样，一个一个把数据填进寄存器，再统一发送到点阵屏上。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"></span><br><span class="line">sbit RCK=P3^5;		//RCLK</span><br><span class="line">sbit SCK=P3^6;		//SRCLK</span><br><span class="line">sbit SER=P3^4;		//SER</span><br><span class="line"></span><br><span class="line"><span class="section">#define MATRIX<span class="emphasis">_LED_</span>PORT    P0</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"><span class="bullet">  *</span> @brief  	控制每一列的输入</span><br><span class="line"><span class="bullet">  *</span> @param  </span><br><span class="line"><span class="bullet">  *</span> @retval </span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">void _74HC595_WriteByte(unsigned char Byte)</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	unsigned char  i;</span></span><br><span class="line"><span class="emphasis">	for(i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="emphasis">	&#123;</span></span><br><span class="line"><span class="emphasis">		SER=Byte&amp;(0x80&gt;&gt;i);</span></span><br><span class="line"><span class="emphasis">		SCK=1;</span></span><br><span class="line"><span class="emphasis">		 SCK=0;</span></span><br><span class="line"><span class="emphasis">	</span></span><br><span class="line"><span class="emphasis">	&#125;</span></span><br><span class="line"><span class="emphasis">	RCK=1;RCK=0;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">/*</span>*</span><br><span class="line"><span class="bullet">  *</span> @brief  点阵屏显示一列数据</span><br><span class="line"><span class="bullet">*</span> @param  column 要选择的列，范围0-7，date 要选择的列的数据，高位在上，1为亮</span><br><span class="line"><span class="bullet">  *</span> @retval </span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">void MatrixLED_ShowColumn(unsigned char column,date)</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">	_74HC595_WriteByte(date);</span></span><br><span class="line"><span class="emphasis">	MATRIX_LED_PORT=~(0x80&gt;&gt;column);</span></span><br><span class="line"><span class="emphasis">	delay(1);</span></span><br><span class="line"><span class="emphasis">	MATRIX_LED_PORT=0xFF;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">void main()</span></span><br><span class="line"><span class="emphasis">&#123;		SCK=0;</span></span><br><span class="line"><span class="emphasis">		RCK=0;		///</span></span><br><span class="line"><span class="emphasis">		</span></span><br><span class="line"><span class="emphasis">     while(1)</span></span><br><span class="line"><span class="emphasis">&#123;	</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(0,0x3c);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(1,0x42);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(2,0xA9);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(3,0x85);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(4,0x85);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(5,0xA9);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(6,0x42);</span></span><br><span class="line"><span class="emphasis">MatrixLED_ShowColumn(7,0x3c);</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这是一个简单的在点阵屏显示笑脸的代码，没有进行模块化处理，想要模块化处理就定义一个初始化函数跟一个显示函数就可以了，当然，这个点阵屏也是实时扫描的，所以想进行同时进行其他任务比较困难，当然也可以带上定时器试试。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#include <span class="language-xml"><span class="tag">&lt;<span class="name">REGX52.H</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="section">#include &quot;MatrixLED.h&quot;</span></span><br><span class="line"></span><br><span class="line">unsigned char code Animation[]=</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;					//这个数组存放所有的列的信息</span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	unsigned char i,offset,count=0;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	void Martrix_LED_Init();</span></span><br><span class="line"><span class="code">     while(1)</span></span><br><span class="line"><span class="code">&#123;	</span></span><br><span class="line"><span class="code">	for(i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">	MatrixLED_ShowColumn(0,Animation[i+offset]);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	count++;</span></span><br><span class="line"><span class="code">	if(count&gt;10)		//调整速度用的</span></span><br><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		count=0;</span></span><br><span class="line"><span class="code">		offset++;		//如果是显示一帧一帧的动画，而不是流水的图案，则需要改成offset+=8;</span></span><br><span class="line"><span class="code">		offset%=24;		//这个要随时调</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些代码可以实现在8*8点阵屏上显示动画，将所有动画的每一行的内容，写进数组Animation中，然后再按照规律进行遍历，就可以显示动画了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向系列</title>
    <url>/2024/11/11/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h3 id="安卓逆向系列"><a href="#安卓逆向系列" class="headerlink" title="安卓逆向系列"></a>安卓逆向系列</h3><p>这系列文章记录一下简单的安卓逆向方面的思路和知识，以备查阅使用。</p>
<h3 id="安卓基本框架"><a href="#安卓基本框架" class="headerlink" title="安卓基本框架"></a>安卓基本框架</h3><p>apk相当于一个zip文件，里面打包了这个安卓程序所有的资源和代码，逆向也是对这个zip文件进行处理。</p>
<p>assets目录：存放静态资源，如视频，图片，音乐等等，一般可以用来替换图像。</p>
<p>lib目录：动态链接库</p>
<p>META-INF目录：保存应用签名信息，逆向安卓程序常常需要去除签名验证，否则程序会无法运行。</p>
<p>res目录：也是存放资源的文件，apk的图标就是在这里面调整。</p>
<p>AndroidManifest.xml文件：储存了安卓包的基本信息，比如应用名字，版本，包名，权限等等，一般处理共存或者去除更新会需要处理这个文件，也可以删除一些你不想要的权限，防止权限过度索取。</p>
<p>classes.dex文件：安卓主要的逻辑代码文件，大部分逆向破解都是在这里面修改判断逻辑，有一个或者很多文件。</p>
<p>resources.arsc文件：映射表，映射资源和id，当dex搜索不到关键词时可以来这里进行搜索，获取到资源id后然后再在dex里搜索。</p>
<h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>基本上字符串都在arsc里，直接选中arsc文件并且进入翻译模式就可以了，可以一个个手动翻译，也可以用插件翻译。</p>
<p>也可以在安装包里全局搜索（开启高级搜索），就可以直接搜索到相应的字符串。如果碰到了不知道语言的一段文字，可以使用开发者助手，授权root权限后，在对应应用中选择界面资源分析，就可以选中并且复制该段文字，再进行全局搜索。</p>
<p>替换图标，就用np管理器的通用编辑即可，可以一键修改图标，版本或者名字</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>逆向 安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>python人脸检测</title>
    <url>/2024/11/15/python%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="python人脸检测"><a href="#python人脸检测" class="headerlink" title="python人脸检测"></a>python人脸检测</h1><p>最近突然对图像识别有了点兴趣，便开始找一些识别的库，我这里采用的是python+opencv的方法，利用opencv内置的人脸检测库，可以比较方便快速地检测出人脸，学的很浅，也就图一乐。记录下来也只是为了以后便于回忆。</p>
<h2 id="将图片转化为灰度图片"><a href="#将图片转化为灰度图片" class="headerlink" title="将图片转化为灰度图片"></a>将图片转化为灰度图片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line">cv.imshow(&#x27;test&#x27;, img)</span><br><span class="line">gray<span class="emphasis">_img = cv.cvtColor(img, cv.COLOR_</span>BGR2GRAY)</span><br><span class="line">cv.imshow(&#x27;gray&#x27;, gray<span class="emphasis">_img)</span></span><br><span class="line"><span class="emphasis">cv.imwrite(&#x27;testlca_</span>gray.jpg&#x27;, gray<span class="emphasis">_img)</span></span><br><span class="line"><span class="emphasis">cv.waitKey(0)</span></span><br><span class="line"><span class="emphasis">cv.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>



<p>首先读取名叫testlca.jpg的图片，并且将它的命名为img，然后展示这个图片，再用opencv内置的函数，将这个图片转化为灰度图片，并且写入到testlca_gray.jpg文件，也展示这个图片。</p>
<p>一般处理图片，都需要先将其转化为灰度图片，然后再进行一系列的识别等步骤。</p>
<h2 id="调整图片大小"><a href="#调整图片大小" class="headerlink" title="调整图片大小"></a>调整图片大小</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line">cv.imshow(&#x27;test&#x27;, img)</span><br><span class="line">resize<span class="emphasis">_test = cv.resize(img, (200,200), fx=0.5, fy=0.5)</span></span><br><span class="line"><span class="emphasis">cv.imshow(&#x27;resize_</span>test&#x27;, resize<span class="emphasis">_test)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">while True:</span></span><br><span class="line"><span class="emphasis">    if ord(&#x27;q&#x27;) == cv.waitKey(0):</span></span><br><span class="line"><span class="emphasis">        break</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">cv.destroyAllWindows()</span></span><br></pre></td></tr></table></figure>



<p>同样读取文件，这里将img图片进行了修改，将它转化为200*200像素的图片，并且也展示出来，还做了一个按键检测，当按下q的时候，图片才会关闭。</p>
<h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">x,y,w,h = 100,100,100,100</span><br><span class="line">cv.rectangle(img, (x,y), (x+w,y+h), (0,0,255), 2)</span><br><span class="line">cv.circle(img, (x+w//2,y+h//2), 50, (0,255,0), 2)</span><br><span class="line"></span><br><span class="line">cv.imshow(&#x27;img&#x27;, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line"><span class="code">    if ord(&#x27;q&#x27;) == cv.waitKey(0):</span></span><br><span class="line"><span class="code">        break</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>



<p>这里定义并赋值了4个变量，并且在图片上打印了对应位置的矩形和圆形。</p>
<h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">def face_detect_demo():</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    face_detector = cv.CascadeClassifier(&#x27;E:/python/opencv/sources/data/haarcascades/haarcascade_eye.xml&#x27;)</span><br><span class="line">    face = face_detector.detectMultiScale(gray,1.9,5)</span><br><span class="line">    for x, y, w, h in face:</span><br><span class="line">        cv.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 2)</span><br><span class="line">    cv.imshow(&#x27;result&#x27;, img)</span><br><span class="line"></span><br><span class="line">img = cv.imread(&#x27;testlca.jpg&#x27;)</span><br><span class="line">face_detect_demo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    if ord(&#x27;q&#x27;) == cv.waitKey(0):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>



<p>先定义了一个检测函数，这里非常简陋，也没做参数处理了，原理就是调用官方的人脸识别库识别出图片中的人脸，并且用矩形框显示出来。</p>
<p>其中face_detector.detectMultiScale这个函数中的第二个变量叫缩小比例，是影响效果的重要变量，要选取适当的变量值才可以正确的识别出所有人脸。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次离谱的刷机经历</title>
    <url>/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在我爸换新手机后，我果断拿掉了我爸的旧手机，想来锻炼我的刷机技巧，我爸的手机是努比亚z17，已经非常老了，但在当时这台手机可是非常出名的，酷安评分非常高，刷机资源也比较多，我于是便开始了我的刷机操作。</p>
<h1 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h1><p>这款机型的刷机本来应该就是一个行云流水的通用刷机操作，努比亚z17有bl锁，只需要每次输一次解锁命令就可以解bl锁，非常容易，但是我却碰到了个非常棘手的情况。</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/147DDA3A399B7028E94DA70AEB855EA9.jpg" alt="故障1"></p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/0F5E47584C7EA15BE8769031F2B066AF.jpg" alt="故障2"></p>
<p>特别离谱是吧。就是这样子的，adb devices跟fastboot devices可以正常读取到设备，但就是传不了boot.img到机器上，bl锁也显示已经解了，各种不同的原因报错，我找了整整几个小时，换了无数根线，甚至还担心是不是接口2.0的问题，还换了台电脑测试，结果就只是报错的原因不一样。</p>
<p>我真的几乎放弃了，已经不打算刷机了，无聊地刷着酷安，也在徒劳的问大佬们问题，酷安一位酷u给我推荐了某贼的一篇文章，就是针对这台设备通过9008授权深刷的，本身这台机子进入9008模式不需要工程线，或者拆机短接等复杂的操作，直接在fb界面就可以进入9008了。</p>
<p>于是，我带着仅剩的一点希望，下载某贼的深刷包，开始下一次测试。</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/26F4F6D59768EDD41DDD40BD92811E61.jpg" alt="9008"></p>
<p>可是没想到又翻车了。</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/6C76DD8FB7980640E3EA4AED489F93C4.jpg" alt="9008故障"></p>
<p>后来我灵机一动，想到我在安装一个驱动提示要重启时，没有理这个重启提示，直接进行操作了，难怪报错了。</p>
<p>重启后再试了一次，非常成功，从安卓8升到了安卓9，fastboot也可以正常使用了，twrp，启动！</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/6B22BBA244B574F699C845781E012A7A.jpg" alt="trwp1"></p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/47304F0030363AB5DECB43089BD89B01.jpg" alt="twrp2"></p>
<p>非常丝滑的一顿操作，修补镜像，刷入magisk，成功获取root权限，也成功开始使用魔趣类原生，真没想到，魔趣系统虽然已经停止运营了，但我仍然再sourceforge平台上找到了他的包，甚至还是专门针对努比亚z17做的包，哎，这是上一个刷机时代的眼泪啊，酷安遗风了。</p>
<p>附张使用图</p>
<p><img src="/2024/11/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E5%88%B7%E6%9C%BA/60105DFB27E857021D7BC119FC4285FC.jpg" alt="moqu"></p>
<p>接着刷入了gaps，美滋滋，这一段玩机之旅也告一段落了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这或许就是刷机搞机的魅力吧，你可能会碰到无数问题，任何一个细节的问题都是致命的，比如中文路径什么的，但是解决了却非常有成就感，其实我看的某贼的那篇文章，是为了解决努比亚z17获取永久bl权限的，只有那个版本的包可以一行代码永久去除bl锁，但是却误打误撞解决了我的问题。</p>
<p>这次经历也告诉我们，碰到这种离奇的报错，可能是系统问题，尝试用9008或者com1.0深刷换一个系统，说不定有机会解决，我碰到的这个问题，网上我目前还没找到类似的问题和解决方案。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
</search>
